{
  "version": 3,
  "sources": ["../../src/helpers/types.js", "../../src/helpers/object.observer.js", "../../src/helpers/objects.js", "../../src/core/simple.js", "../../src/helpers/functions.js", "../../src/core/base.js", "../../src/core/cssprops.js", "../../src/core/viewport.js"],
  "sourcesContent": ["export const FUNCTION  = 'function';\r\nexport const UNDEFINED = 'undefined';\r\nexport const OBJECT    = 'object';\r\nexport const STRING    = 'string';\r\nexport const ARRAY     = 'array';\r\nexport const NUMBER    = 'number';\r\nexport const BOOLEAN   = 'boolean';\r\nexport const DATE      = 'date';\r\nexport const SYMBOL    = 'symbol';\r\n\r\nexport const EMPTY_STRING = '';\r\nexport const COMA         = ',';\r\nexport const COLON        = ':';\r\nexport const SEMICOLON    = ';';\r\n\r\nexport const isObject    = (v) => typeof v === OBJECT;\r\nexport const isString    = (v) => typeof v === STRING;\r\nexport const isFunction  = (v) => typeof v === FUNCTION;\r\nexport const isNumber    = (v) => typeof v === NUMBER && !isNaN(v);\r\nexport const isUndefined = (v) => typeof v === UNDEFINED;\r\nexport const isSymbol    = (v) => typeof v === SYMBOL;\r\nexport const isBoolean   = (v) => typeof v === BOOLEAN;\r\nexport const isArray     = (v) => Array.isArray(v);\r\nexport const isDate      = (v) => v instanceof Date && !isNaN(v);\r\nexport const isNull      = (v) => v === null;\r\n\r\n/**\r\n * Convert attribute name to camel property name\r\n * @param {string} name\r\n * @return {string}\r\n */\r\nexport const toCamel = name => name.replace(/-([a-z0-9])/g, (x, y) => y.toUpperCase());\r\n\r\n/**\r\n * Converto property name to hyphen attribute name\r\n * @param {string} name\r\n * @return {string}\r\n */\r\nexport const toHyphen = name => {\r\n  name = name.replace(/([A-Z])/g, '-$1').toLowerCase();\r\n  return name.startsWith('-') ? name.slice(1) : name;\r\n};\r\n\r\n\r\n/**\r\n * Convert an object property to an attribute string\r\n * @param {Object} value\r\n * @return {string|undefined}\r\n */\r\nexport function object2attribute (value) {\r\n  if (isObject(value)) {\r\n    let str = '';\r\n    for (let key of Object.keys(value)) {\r\n      str += `${ str ? '; ' : '' }${ key }: ${ value[key] }`;\r\n    }\r\n    return str;\r\n  } else if (isString(value)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Convert an attribute string to an object property\r\n * @param {string} value\r\n * @return {Object|undefined}\r\n */\r\nexport function attribute2object (value) {\r\n  if (isString(value)) {\r\n    try {\r\n      const normalized = value\r\n        .replace(/^\\s*{/,'')\r\n        .replace(/}\\s*$/,'')\r\n        .split(/((?:[^;^,\"']|\"[^\"]*\"|'[^']*')+)/)\r\n        .filter(partial => !['', ';', ','].includes(partial.trim()))\r\n        .map(partial => partial.split(':'))\r\n        .map(partial => `\"${ partial[0].trim() }\":${ str2value(\r\n          partial[1].trim(),\r\n          undefined,\r\n          true\r\n        ) }`)\r\n        .join(',');\r\n      return JSON.parse(`{${ normalized }}`);\r\n    } catch (err) {\r\n      console.error(err);\r\n      return undefined;\r\n    }\r\n  } else if (isObject(value)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Convert an attribute string to an array\r\n * @param {string} value\r\n * @return {Object|undefined}\r\n */\r\nexport function attribute2array (value) {\r\n  if (isString(value)) {\r\n    if (value.trim().startsWith('[')) {\r\n      return (value.match(/\\[(.*?)[^\\]]]/g) || []).map(arr => attribute2array(arr.substring(\r\n        1,\r\n        arr.length - 1\r\n      )));\r\n    } else {\r\n      return value.split(/[,;]/).map(str => str2value(str.trim()));\r\n    }\r\n  } else if (isArray(value)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Convert an attribute string to an array of objects\r\n * @param {string} value\r\n * @return {Object|undefined}\r\n */\r\nexport function attribute2arrayObject (value) {\r\n  if (isString(value)) {\r\n    if (value.trim().startsWith('[')) {\r\n      return (value.match(/\\[(.*?)[^\\]]]/g) || []).map(arr => attribute2object(arr.substring(\r\n        1,\r\n        arr.length - 1\r\n      )));\r\n    } else {\r\n      return [attribute2object(value)];\r\n    }\r\n  } else if (isArray(Array)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n\r\n/**\r\n *\r\n * @param {Object|string} value\r\n * @return {string|undefined}\r\n */\r\nexport function array2attribute (value) {\r\n  if (isArray(value)) {\r\n    let str = JSON.stringify(value);\r\n    return str.substring(1, str.length - 1)\r\n              .replace(/,/g, ', ')\r\n              .replace(/\"/g, '');\r\n  } else if (isString(value)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Convert a string into a value number, boolean or string (with \"\" if quote is true)\r\n * @private\r\n * @param {string} str\r\n * @param {string} [type]\r\n * @param {boolean} [quote=false]\r\n * @return {any}\r\n */\r\nexport function str2value (str, type, quote = false) {\r\n  if (!isString(str)) {\r\n    return str;\r\n  }\r\n  str = removeDoubleQuote(str.trim());\r\n  if (type === ARRAY) {\r\n    return attribute2array(str);\r\n  }\r\n  if (type === OBJECT) {\r\n    return attribute2object(str);\r\n  }\r\n  if (isUndefined(type) || type === NUMBER) {\r\n    if (isUndefined(str) || str === '') {\r\n      return undefined;\r\n    }\r\n    let value = +str;\r\n    if (!Number.isNaN(value) || type === NUMBER) {\r\n      return value;\r\n    }\r\n  }\r\n  if (isUndefined(type) || type === BOOLEAN) {\r\n    if (str === 'true') {\r\n      return true;\r\n    } else if (str === 'false') {\r\n      return false;\r\n    }\r\n    if (type === BOOLEAN) {\r\n      if (str === '0') {\r\n        return false;\r\n      }\r\n      return !!str;\r\n    }\r\n  }\r\n  if (type === DATE) {\r\n    try {\r\n      let value = new Date(str);\r\n      if (!Number.isNaN(value.getTime())) {\r\n        return value;\r\n      }\r\n    } catch (e) {\r\n      void (0);\r\n    }\r\n    return undefined;\r\n  }\r\n  if (isUndefined(type) || type === STRING) {\r\n    return quote ? `\"${ str }\"` : str;\r\n  }\r\n}\r\n\r\nfunction removeDoubleQuote (str) {\r\n  if (\r\n    (str[0] === '\\'' && str[str.length - 1] === '\\'') ||\r\n    (str[0] === '\"' && str[str.length - 1] === '\"')\r\n  ) {\r\n    return str.substring(1, str.length - 1);\r\n  }\r\n  return str;\r\n}\r\n\r\n/**\r\n *\r\n * @param {string} str\r\n * @returns {boolean}\r\n */\r\nexport function isLikeObject(str) {\r\n  return /^\\s*{(.|\\s)*}\\s*$/.test(str);\r\n}\r\n\r\n/**\r\n *\r\n * @param {string} str\r\n * @returns {boolean}\r\n */\r\nexport function isLikeArray(str) {\r\n  return /^\\s*\\[(.|\\s)*]\\s*$/.test(str);\r\n}\r\n\r\n\r\nexport function csvStr2obj (str) {\r\n  let keys = [];\r\n  return str\r\n    .split(/(\\r\\n|\\r|\\n)/)\r\n    .map(r => r.trim())\r\n    .filter(r => r)\r\n    .reduce(\r\n      (result, row, idx) => {\r\n        const obj   = {};\r\n        const parts = row\r\n          .split(/((?:[^;^,\"']|\"[^\"]*\"|'[^']*')+)/)\r\n          .filter(partial => ![EMPTY_STRING, SEMICOLON, COMA].includes(partial.trim()));\r\n        if (idx === 0) {\r\n          keys = [...parts.map(p => JSON.parse(p))];\r\n          return result;\r\n        }\r\n        parts.forEach((part, i) => {\r\n          obj[keys[i]] = JSON.parse(part);\r\n        });\r\n        result.push(obj);\r\n        return result;\r\n      },\r\n      []\r\n    );\r\n}\r\n\r\nexport function jsStr2obj (str) {\r\n  const code = `return (${ str });`\r\n  const ret  = (new Function(code))();\r\n  return typeof ret === 'function' ? ret() : ret;\r\n}\r\n\r\nexport function funcStr2obj (str, $) {\r\n  return (new Function('$', `${ str };let ___$$$ret = {};${\r\n    [...str.matchAll(/\\s*function\\s*(\\w+)/gm)]\r\n      .map(x => `if (typeof ${ x[1] } === 'function') ___$$$ret.${ x[1] } = ${ x[1] };`)\r\n      .join('')\r\n  } return ___$$$ret;`))($);\r\n}", "import {\r\n  isObject, isNull, isFunction, isDate, isString\r\n} from './types.js';\r\n\r\n/**\r\n * Observe an object in deep\r\n * @param {Object}  obj        - object to observe\r\n * @param {Function} callback  - function called when any is changed\r\n * @return {Object}\r\n */\r\n\r\nconst cache = new WeakSet();\r\nlet ignore  = false;\r\n\r\n/**\r\n * Observe an object modifications\r\n * @param {Object}   object\r\n * @param {Function} callback\r\n * @returns {Object}\r\n */\r\nexport const objectObserver = (object, callback) => {\r\n  if (!isFunction(callback)) {\r\n    return object;\r\n  }\r\n  return (function observe (obj) {\r\n    if (cache.has(obj)) {\r\n      return obj;\r\n    }\r\n    for (let prop in obj) {\r\n      if (isObject(obj[prop]) && !isNull(obj[prop])) {\r\n        obj[prop] = observe(obj[prop]);\r\n      }\r\n    }\r\n    const result = new Proxy(obj, {\r\n      get (target, prop) {\r\n        let value = Reflect.get(obj, prop);\r\n        if (isFunction(value) &&\r\n            isDate(target) &&\r\n            isString(prop) &&\r\n            prop.substring(0, 3) === 'set' &&\r\n            isFunction(callback)\r\n        ) {\r\n          value = function (...args) {\r\n            const ret = Reflect.get(target, prop).apply(target, args);\r\n            !ignore && callback(object);\r\n            return ret;\r\n          }\r\n        }\r\n        return isDate(target) ? value.bind(target) : value;\r\n      },\r\n      set (target, prop, value) {\r\n        let ret;\r\n        const same = target[prop] === value;\r\n        if (isObject(value) && !isNull(value)) {\r\n          ret = Reflect.set(target, prop, observe(value));\r\n        } else {\r\n          ret = Reflect.set(target, prop, value);\r\n        }\r\n        !ignore && !same && callback(object);\r\n        return ret;\r\n      },\r\n      deleteProperty (target, prop) {\r\n        let ret = Reflect.deleteProperty(target, prop);\r\n        !ignore && callback(object);\r\n        return ret;\r\n      }\r\n    });\r\n    cache.add(result);\r\n    return result;\r\n  })(object);\r\n};\r\n\r\nobjectObserver.stop  = () => ignore = true;\r\nobjectObserver.start = () => ignore = false;\r\n\r\nexport default objectObserver;", "import {\r\n  OBJECT, NUMBER, UNDEFINED,\r\n  isObject, isFunction, isString, isUndefined, isNull\r\n} from './types.js';\r\n\r\nconst NOT_EQUAL = false;                            // Return values\r\nconst EQUAL     = true;\r\n\r\n/**\r\n * Create a new object (empty) with same constructor\r\n * @param {object} obj - object as seed\r\n * @returns {object}   - a new object\r\n */\r\nexport function createOther (obj) {\r\n  if (obj === null) return null;\r\n  if (obj.constructor) {\r\n    return new obj.constructor();\r\n  }\r\n  return {};\r\n}\r\n\r\n/**\r\n * Clone an object (plain object and array)\r\n * @param {object} obj - object to clone\r\n * @returns {object}   - new object\r\n */\r\nexport function clone (obj) {\r\n  if (!isObject(obj)) {\r\n    return obj;\r\n  }\r\n  const copy = obj === null ? null : Object.assign(createOther(obj), obj);\r\n  for (let p in copy) {\r\n    if (isObject(copy[p])) {\r\n      copy [p] = clone(copy[p]);\r\n    }\r\n  }\r\n  return copy;\r\n}\r\n\r\n/**\r\n * Object comparison (equivalent with same all enumerable properties and equal constructor)\r\n * @param {*} objectA - first object to comparison\r\n * @param {*} objectB - second object to comparison\r\n * @returns {boolean}\r\n */\r\nexport function equal (objectA, objectB) {\r\n  const aStack = [],                             // Stack array\r\n        bStack = [];\r\n\r\n  /**\r\n   * Compare objects\r\n   * @param {object} a - first object\r\n   * @param {object} b - second object\r\n   * @returns {boolean}\r\n   */\r\n  function checkObject (a, b) {\r\n    if (a === null || b === null) {              // if one is null, they are different\r\n      return NOT_EQUAL;\r\n    }\r\n\r\n    if (\r\n      isFunction(a.valueOf) &&         // valueOf() is a function in both values\r\n      isFunction(b.valueOf) &&\r\n      (a !== a.valueOf() || b !== b.valueOf())\r\n    ) {\r\n      return (\r\n        a.valueOf() === b.valueOf() &&\r\n        a.constructor === b.constructor);        // Check if equal\r\n    }\r\n\r\n    if (aStack.indexOf(a) > -1 &&               // Check if the object has been previously processed\r\n        bStack.indexOf(b) > -1) {\r\n      return EQUAL;\r\n    }\r\n    let aKeys = Object.keys(a);                 // Get property keys\r\n    let bKeys = Object.keys(b);\r\n    if (aKeys.length !== bKeys.length) {         // Check the number of properties\r\n      return NOT_EQUAL;\r\n    }\r\n    if (aKeys.length > 0) {\r\n      aStack.push(a);                           // Storage objects into stacks for recursive references\r\n      bStack.push(b);\r\n      let i = aKeys.length;\r\n      while (i--) {                              // Check each property value (recursive call)\r\n        const key = aKeys[i];\r\n        if (!check(a[key], b[key])) {\r\n          return NOT_EQUAL;\r\n        }\r\n      }\r\n    }\r\n    return EQUAL;\r\n  }\r\n\r\n  /**\r\n   * Compare elements\r\n   * @param {*} a - first element\r\n   * @param {*} b - second element\r\n   * @returns {boolean}\r\n   */\r\n  function check (a, b) {\r\n    if (a === b) {                               // Strict comparison\r\n      return EQUAL;\r\n    }\r\n    const aType = typeof a,                      // Get value types\r\n          bType = typeof b;\r\n    if (aType !== bType) {                       // Different type is a not equal value from this point\r\n      return NOT_EQUAL;\r\n    }\r\n    if (aType === NUMBER &&                    // Special case: Not is a Number (NaN !== NaN)\r\n        isNaN(a) &&\r\n        isNaN(b)) {\r\n      return EQUAL;\r\n    }\r\n\r\n    if (aType === OBJECT) {                    // Objects\r\n      return checkObject(a, b);\r\n    }\r\n    return NOT_EQUAL;                            // Not equal\r\n  }\r\n\r\n  return check(objectA, objectB);\r\n}\r\n\r\n/**\r\n * get a deep property\r\n * @param {object} obj\r\n * @param {string|array|Symbol} path\r\n * @returns {undefined|*}\r\n */\r\nexport function getProperty (obj, path) {\r\n  let tmp      = obj;\r\n  let elements = isString(path) ? path.split('.') : path;\r\n  for (let i = 0; i < elements.length; i++) {\r\n    if (isUndefined(tmp[elements[i]])) {\r\n      return undefined;\r\n    }\r\n    tmp = tmp[elements[i]];\r\n  }\r\n  return tmp;\r\n}\r\n\r\n/**\r\n * Create a Schema object\r\n * @param {object} schema\r\n * @returns {{normalize(object): void}}\r\n * @constructor\r\n */\r\nexport function Schema (schema) {\r\n  walker(schema, (obj, key) => {\r\n    if (!obj.$schema && (key === 'properties' || key === 'items')) {\r\n      obj.$schema = {};\r\n      obj.$schema = Schema(obj);\r\n    }\r\n  });\r\n  const arrayNormalization  = (obj) => { // Array\r\n    if (!Array.isArray(obj)) {\r\n      obj = [];\r\n    }\r\n    for (let key in obj) {\r\n      // Update type\r\n      const type = getType(obj[key]);\r\n      if (type !== schema.items.type.name) {\r\n        obj[key] = new schema.items.type(obj[key]).valueOf();\r\n      }\r\n      // Sub schema\r\n      if (schema.items.$schema) {\r\n        obj[key] = schema.items.$schema.normalize(obj[key]);\r\n      }\r\n    }\r\n    return obj;\r\n  };\r\n  const objectNormalization = (obj) => { // Object\r\n    if (!isObject(obj)) {\r\n      obj = {};\r\n    }\r\n    const {properties} = schema;\r\n    for (let key in obj) {\r\n      const property = properties[key];\r\n      // Remove unknown values\r\n      if (!property) {\r\n        delete obj[key];\r\n        continue;\r\n      }\r\n      // Update type\r\n      if (getType(obj[key]) !== property.type.name) {\r\n        obj[key] = new property.type(obj[key]).valueOf();\r\n        if (getType(obj[key]) !== property.type.name || (property.type === Number && Number.isNaN(obj[key]))) {\r\n          delete obj[key];\r\n        }\r\n      }\r\n      // Sub schema\r\n      if (property.$schema) {\r\n        obj[key] = property.$schema.normalize(obj[key]);\r\n      }\r\n    }\r\n    // Add missing values\r\n    for (let key in properties) {\r\n      const property = properties[key];\r\n      if (isUndefined(obj[key]) && !isUndefined(property.default)) {\r\n        obj[key] = new property.type(property.default).valueOf();\r\n      }\r\n      if (property.$schema) {\r\n        obj[key] = property.$schema.normalize(obj[key]);\r\n      }\r\n    }\r\n    return obj;\r\n  };\r\n  return {normalize : schema.items ? arrayNormalization : objectNormalization}\r\n}\r\n\r\n/**\r\n * @typedef walkerCallback\r\n * @type function\r\n * @param {object} obj\r\n * @param {string} key\r\n * @param {*} value\r\n * @param {object} root\r\n * @param {array<string>} keys\r\n */\r\n\r\n/**\r\n * Walk a object keys\r\n * @param {object} obj\r\n * @param {walkerCallback} callback\r\n */\r\nexport function walker (obj, callback) {\r\n  if (!isObject(obj) || !isFunction(callback)) {\r\n    return;\r\n  }\r\n  (function inspect (currentObj, keys) {\r\n    for (let key in currentObj) {\r\n      keys.push(key);\r\n      if (isObject(currentObj[key])) {\r\n        inspect(currentObj[key], keys);\r\n      }\r\n      callback(currentObj, key, currentObj[key], obj, keys);\r\n      keys.pop();\r\n    }\r\n  })(obj, []);\r\n}\r\n\r\nfunction getType (value) {\r\n  if (isNull(value)) {\r\n    return 'null';\r\n  }\r\n  if (isUndefined(value)) {\r\n    return UNDEFINED;\r\n  }\r\n  return value.constructor.name\r\n}", "/**\r\n *\r\n * Simple class for Graphane web component\r\n *\r\n * @module simple\r\n * @version 0.0.2\r\n * @author Pablo Almunia\r\n *\r\n */\r\nimport {\r\n  str2value, toCamel, isUndefined, isFunction, isObject, isString, isNull,\r\n  NUMBER, BOOLEAN, OBJECT, ARRAY, EMPTY_STRING,\r\n}                     from '../helpers/types.js';\r\nimport objectObserver from '../helpers/object.observer.js';\r\nimport {\r\n  equal, clone\r\n}                     from '../helpers/objects.js';\r\n\r\n// Constants\r\nconst COMPONENT_PREFIX = globalThis.GRAPHANE_PREFIX || 'g-';\r\n\r\n// private symbols\r\n/**\r\n * Symbol used for defines a private context used with `this [ CONTEXT ]`.\r\n * @type {symbol}\r\n */\r\nconst INITIALIZERS = Symbol();\r\n\r\n// Public symbols\r\n/**\r\n * Symbol used for defines a private context used with `this [ CONTEXT ]`.\r\n * @type {symbol}\r\n */\r\nconst CONTEXT    = Symbol();\r\n/**\r\n * Symbol used for defines the LOCAL DOM CHANGE event handler into the class\r\n * inherited from Simple. This method is called when the Local Dom component is\r\n * changed, includes its attributes.\r\n * @type {symbol}\r\n */\r\nconst CHANGE     = Symbol();\r\n/**\r\n * Symbol used as method name for fire an event.\r\n * @type {symbol}\r\n */\r\nconst FIRE_EVENT = Symbol();\r\n/**\r\n * Shortcut to Object.defineProperty\r\n * @type {(o: object, p: PropertyKey, attributes: (PropertyDescriptor))}\r\n */\r\nconst defProp    = Object.defineProperty;\r\n\r\n/**\r\n * Update an attribute into the HTML\r\n * @param {HTMLElement} element\r\n * @param {string} attribute\r\n * @param {any} value\r\n * @param {boolean} [asBoolean=false]\r\n * @returns {undefined}\r\n */\r\nfunction updateAttribute (element, attribute, value, asBoolean = false) {\r\n  if (element.ready === false || !attribute) {\r\n    return;\r\n  }\r\n  if (asBoolean) {\r\n    if (value) {\r\n      element.setAttribute(attribute, EMPTY_STRING);\r\n    } else {\r\n      element.removeAttribute(attribute);\r\n    }\r\n  } else {\r\n    const valueNormalized = isNull(value) || isUndefined(value) ? EMPTY_STRING : value.toString();\r\n    if (element.hasAttribute(attribute) && element.getAttribute(attribute) !== valueNormalized) {\r\n      element.setAttribute(attribute, valueNormalized);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Initialize context values\r\n */\r\nfunction initValues (target) {\r\n  this[CONTEXT] = {};\r\n  let proto     = target;\r\n  do {\r\n    const init = initialValues.get(proto);\r\n    for (let p in init) {\r\n      // See: https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\r\n      if (init.hasOwnProperty(p) && this.hasOwnProperty(p)) {\r\n        const tmp = this[p];\r\n        delete this[p];\r\n        this[p] = isUndefined(tmp) ? clone(init[p]) : tmp;\r\n      } else if (!(p in this[CONTEXT])) {\r\n        this[CONTEXT][p] = clone(init[p]);\r\n      }\r\n    }\r\n    proto = Object.getPrototypeOf(proto);\r\n  } while (proto !== HTMLElement);\r\n}\r\n\r\n/**\r\n * Active the mutation observer\r\n */\r\nfunction observeMutation () {\r\n  new MutationObserver((mutations) => {\r\n    for (let mutation of mutations) {\r\n      if (!mutation.attributeName) {\r\n        this[FIRE_EVENT]('update');\r\n        break;\r\n      }\r\n    }\r\n    if (\r\n      (isUndefined(this.ready) || this.ready) &&\r\n      isFunction(this[CHANGE])\r\n    ) {\r\n      this[CHANGE](mutations);\r\n    }\r\n  }).observe(this, {attributes : true, childList : true, subtree : true, characterData : true});\r\n}\r\n\r\n\r\n// Global initial values\r\nconst initialValues = new WeakMap();\r\n\r\n/**\r\n * Simple class for Graphane Web Component\r\n *\r\n * @fires 'update'  - This event fires when the component is changed\r\n */\r\nclass Simple extends HTMLElement {\r\n\r\n  constructor () {\r\n    super();\r\n    initValues.call(this, new.target);\r\n    new.target[INITIALIZERS]?.forEach(fn => isFunction(fn) && fn.call(this, this));\r\n    if (isFunction(this[CHANGE])) {\r\n      observeMutation.call(this);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fire an event\r\n   * @private\r\n   * @param {string} event             - event name\r\n   * @param {Object} [detail={}]       - optional event detail object\r\n   * @param {boolean} [composed=false] - optional event propagate across the shadow DOM boundary\r\n   * @returns {boolean}                - return true\r\n   */\r\n  [FIRE_EVENT] (event, detail = {}, composed = false) {\r\n    return this.dispatchEvent(new CustomEvent(\r\n      event,\r\n      {bubbles : true, cancelable : true, detail, composed}\r\n    ));\r\n  }\r\n\r\n}\r\n\r\n/**\r\n *\r\n * Attribute descriptor used into defineAttribute\r\n *\r\n * @typedef {Object} attributeDescriptor\r\n * @property {string} name                          - Attribute name.\r\n * @property {string} [propertyName]                - Property name associated with this attribute.\r\n *                                                    If it's omitted a default name is generated\r\n *                                                    with a camel case structure.\r\n * @property {string} [type]                        - Specific type (boolean, number, string,\r\n *                                                    object, array).\r\n * @property {*} [value]                            - Default value.\r\n * @property {Function} [get]                       - Get accessor method.\r\n * @property {Function} [set]                       - Set accessor method.\r\n * @property {(Function|string|symbol)} [preUpdate] - Callback or method reference to be called\r\n *                                                    previously to update.\r\n * @property {(Function|string|symbol)} [posUpdate] - Callback or method reference to be called\r\n *                                                    after update.\r\n * @property {string} [posUpdateEvent]              - Event name fired after the update.\r\n * @property {object} [schema={}]                   - Data Schema\r\n */\r\n\r\n/**\r\n *\r\n * Define an attribute and its property into a class\r\n *\r\n * @param {Class} Class                    - class to extend\r\n * @param {attributeDescriptor} attribute - options into a {@link attributeDescriptor}\r\n */\r\nfunction defineAttribute (Class, attribute) {\r\n\r\n  // Property\r\n  if (!attribute.propertyName) {\r\n    attribute.propertyName = toCamel(attribute.name);\r\n  }\r\n  defineProperty(Class, {\r\n    name           : attribute.propertyName,\r\n    value          : attribute.value,\r\n    get            : attribute.get,\r\n    set            : attribute.set,\r\n    attribute      : attribute.name,\r\n    type           : attribute.type,\r\n    preUpdate      : attribute.preUpdate,\r\n    posUpdate      : attribute.posUpdate,\r\n    posUpdateEvent : attribute.posUpdateEvent,\r\n    schema         : attribute.schema\r\n  });\r\n\r\n  // Prototype\r\n  const prototype = Object.getPrototypeOf(Class);\r\n\r\n  // observedAttributes\r\n  const OBSERVE_ATTRIBUTES         = 'observedAttributes';\r\n  const descriptorObsAttr          = Object.getOwnPropertyDescriptor(\r\n    Class,\r\n    OBSERVE_ATTRIBUTES\r\n  );\r\n  // observedAttributes\r\n  const descriptorObsAttrPrototype = Object.getOwnPropertyDescriptor(\r\n    prototype,\r\n    OBSERVE_ATTRIBUTES\r\n  );\r\n  let previousGet                  = descriptorObsAttr ? descriptorObsAttr.get : undefined;\r\n  defProp(\r\n    Class,\r\n    OBSERVE_ATTRIBUTES,\r\n    descriptorObservedAttributes(\r\n      Class,\r\n      attribute,\r\n      prototype,\r\n      previousGet,\r\n      descriptorObsAttr,\r\n      descriptorObsAttrPrototype\r\n    )\r\n  );\r\n\r\n  // attributeChangedCallback\r\n  const ATTRIBUTE_CHANGED_CALLBACK    = 'attributeChangedCallback';\r\n  const descriptorAttrChgCbk          = Object.getOwnPropertyDescriptor(\r\n    Class.prototype,\r\n    ATTRIBUTE_CHANGED_CALLBACK\r\n  );\r\n  const descriptorAttrChgCbkPrototype = Object.getOwnPropertyDescriptor(\r\n    prototype.prototype,\r\n    ATTRIBUTE_CHANGED_CALLBACK\r\n  );\r\n  let previousFunction                = descriptorAttrChgCbk ?\r\n    descriptorAttrChgCbk.value :\r\n    undefined;\r\n  defProp(\r\n    Class.prototype,\r\n    ATTRIBUTE_CHANGED_CALLBACK,\r\n    defineAttributeDescriptor(attribute, previousFunction, descriptorAttrChgCbkPrototype)\r\n  );\r\n\r\n}\r\n\r\n/**\r\n * Return the attribute descriptor\r\n * @param {Object} attribute\r\n * @param {Function} previousFunction\r\n * @param {Object} descriptorAttrChgCbkPrototype\r\n * @returns {Object}\r\n */\r\nfunction defineAttributeDescriptor (attribute, previousFunction, descriptorAttrChgCbkPrototype) {\r\n  return {\r\n    /**\r\n     * @this {Base}\r\n     */\r\n    value : function (name, oldValue, value) {\r\n      if (attribute.name === name) {\r\n        const propertyName = attribute.propertyName;\r\n        if (this[propertyName] !== value) {\r\n          if (attribute.type === BOOLEAN) {\r\n            this[propertyName] = this.hasAttribute(attribute.name);\r\n          } else {\r\n            this[propertyName] = str2value(value, attribute.type);\r\n          }\r\n        }\r\n      } else if (previousFunction) {\r\n        previousFunction.apply(this, arguments);\r\n      }\r\n      if (descriptorAttrChgCbkPrototype?.value) {\r\n        descriptorAttrChgCbkPrototype.value.apply(this, arguments);\r\n      }\r\n    }\r\n    ,\r\n    enumerable   : false,\r\n    writable     : true,\r\n    configurable : true\r\n  };\r\n}\r\n\r\n/**\r\n * Return the observedAttribute descriptor\r\n * @param {Object} Class\r\n * @param {Object} attribute\r\n * @param {Object} prototype\r\n * @param {Function} previousGet\r\n * @param {Object} descriptorObsAttr\r\n * @param {Object} descriptorObsAttrPrototype\r\n * @returns {Object}\r\n */\r\nfunction descriptorObservedAttributes (Class, attribute, prototype, previousGet, descriptorObsAttr, descriptorObsAttrPrototype) {\r\n  const descriptor = {\r\n    enumerable   : false,\r\n    configurable : true\r\n  };\r\n  if (descriptorObsAttr) {\r\n    if (descriptorObsAttrPrototype) {\r\n      descriptor.get = function () {\r\n        return [attribute.name,\r\n                ...previousGet.call(Class),\r\n                ...descriptorObsAttrPrototype.get.call(prototype)];\r\n      };\r\n    } else {\r\n      descriptor.get = function () {\r\n        return [attribute.name, ...previousGet.call(Class)];\r\n      };\r\n    }\r\n  } else {\r\n    descriptor.get = descriptorObsAttrPrototype ?\r\n      function () {\r\n        return [attribute.name, ...descriptorObsAttrPrototype.get.call(prototype)];\r\n      } :\r\n      function () {\r\n        return [attribute.name];\r\n      };\r\n  }\r\n\r\n  return descriptor;\r\n}\r\n\r\n/**\r\n *\r\n * Property descriptor used into defineProperty\r\n *\r\n * @typedef {Object} propertyDescriptor\r\n * @property {string}                   name              - Property name\r\n * @property {*}                        [value]           - Default value\r\n * @property {string}                   [attribute]       - Associated attribute name\r\n * @property {string}                   [type]            - Specific type (boolean, number, string,\r\n *                                                          function, object, array).\r\n * @property {(Function|string|symbol)} [preUpdate]       - Callback or method to call previously\r\n *                                                          to update\r\n * @property {(Function|string|symbol)} [posUpdate]       - Callback or method reference to call\r\n *                                                          after update\r\n * @property {string}                   [posUpdateEvent]  - Event name fired after update\r\n */\r\n\r\n/**\r\n *\r\n * Define a property into the class\r\n *\r\n * @param {Function} Class              - class to extend\r\n * @param {propertyDescriptor} property - options into a {@link propertyDescriptor}\r\n */\r\nfunction defineProperty (Class, property) {\r\n\r\n  // Property\r\n  defProp(\r\n    Class.prototype,\r\n    property.name,\r\n    {\r\n      set          : definePropertySet(property),\r\n      get          : definePropertyGet(property),\r\n      configurable : true,\r\n      enumerable   : false\r\n    }\r\n  );\r\n\r\n  // Value\r\n  if (!initialValues.has(Class)) {\r\n    initialValues.set(Class, {});\r\n  }\r\n  initialValues.get(Class)[property.name] = property.value;\r\n\r\n}\r\n\r\n/**\r\n * Pos processing function\r\n * @param {Object} property\r\n * @param {*} value\r\n */\r\nfunction pos (property, value) {\r\n  // Event emit\r\n  if (!isNull(property.posUpdateEvent)) {\r\n    if (property.posUpdateEvent) {\r\n      this[FIRE_EVENT](property.posUpdateEvent, {[property.name] : value});\r\n    } else {\r\n      this[FIRE_EVENT]('update', {[property.name] : value});\r\n    }\r\n  }\r\n\r\n  // pos update function\r\n  if (isFunction(property.posUpdate)) {\r\n    property.posUpdate.call(this, value);\r\n  } else if (isFunction(this[property.posUpdate])) {\r\n    this[property.posUpdate]();\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * Return the property set function\r\n * @param {Object} property\r\n * @returns {function}\r\n */\r\nfunction definePropertySet (property) {\r\n  return function (value) {\r\n    let ctx = this[CONTEXT];\r\n\r\n    // Pre\r\n    if (isFunction(property.preUpdate)) {\r\n      if (!property.preUpdate.call(this, value)) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    // Schema normalization\r\n    if (property.schema) {\r\n      objectObserver.stop();\r\n      value = property.schema.normalize(value);\r\n      objectObserver.start();\r\n    }\r\n\r\n    // Is it change?\r\n    if (!isObject(value) && equal(ctx[property.name], value)) {\r\n      return;\r\n    }\r\n\r\n    // Custom update\r\n    if (isFunction(property.set)) {\r\n      property.set.call(this, value);\r\n    } else {\r\n      ctx[property.name] = isString(value) && property.type ?\r\n        // String conversion updated\r\n        str2value(value, property.type) :\r\n        // Other values\r\n        value;\r\n    }\r\n\r\n    // Update attribute\r\n    if (property.attribute && ![ARRAY, OBJECT].includes(property.type)) {\r\n      updateAttribute(this, property.name, value, property.type === BOOLEAN);\r\n    }\r\n\r\n    // Pos update\r\n    pos.call(this, property, value);\r\n\r\n  };\r\n}\r\n\r\n/**\r\n * Return the property get function\r\n * @param {Object} property\r\n * @returns {function}\r\n */\r\nfunction definePropertyGet (property) {\r\n  return function () {\r\n    if (isFunction(property.get)) {\r\n      return property.get.call(this);\r\n    } else {\r\n      const ctx = this[CONTEXT];\r\n      switch (property.type) {\r\n        case NUMBER:\r\n          return isUndefined(ctx[property.name]) ?\r\n            undefined :\r\n            Number(ctx[property.name]);\r\n        case BOOLEAN:\r\n          return !!ctx[property.name];\r\n        case OBJECT:\r\n        case ARRAY:\r\n          return objectObserver(\r\n            ctx[property.name] || (property.type === OBJECT ? {} : []),\r\n            obj => definePropertySet(property).call(this, obj)\r\n          );\r\n        default:\r\n          return ctx[property.name];\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Register the Web Component\r\n * @param {Function} Class - Class for this custom component\r\n * @param {string }name    - Tag Name\r\n */\r\nfunction registreComponent (Class, name) {\r\n\r\n  // Registre custom element\r\n  if (!customElements.get(COMPONENT_PREFIX + name.toLowerCase())) {\r\n    customElements.define(COMPONENT_PREFIX + name.toLowerCase(), Class);\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * Define a Base or\r\n * @param {Function} Class\r\n * @param {Object} [def={}]\r\n * @returns {object}\r\n */\r\nfunction define (Class, def = {}) {\r\n  def.property  = (...properties) => {\r\n    properties.forEach(property => defineProperty(Class, {...property}));\r\n    return def;\r\n  };\r\n  def.attribute = (...attributes) => {\r\n    attributes.forEach(attribute => defineAttribute(Class, {...attribute}));\r\n    return def;\r\n  };\r\n  def.tag       = (name) => {\r\n    registreComponent(Class, name);\r\n    return def;\r\n  };\r\n  def.extension = (fn) => {\r\n    fn.call(def, def, Class)\r\n    return def\r\n  }\r\n  return def;\r\n}\r\n\r\n/**\r\n * Export\r\n */\r\nexport {\r\n  Simple as default,\r\n  Simple,\r\n  define,\r\n  CHANGE,\r\n  CONTEXT,\r\n  FIRE_EVENT,\r\n  COMPONENT_PREFIX\r\n};\r\n", "/**\r\n * Returns a function, that, as long as it continues to be invoked, will not be triggered.\r\n * The function will be called after it stops being called for N milliseconds.\r\n * Warning: does not work correctly for methods, use debounceMethod() in that case.\r\n * @param {Function} fn   - original function\r\n * @param {number}   wait - number of milliseconds before the call\r\n * @return {Function}\r\n */\r\nexport function debounce (fn, wait) {\r\n  let n = 0;\r\n  return function (...args) {\r\n    clearTimeout(n);\r\n    n = setTimeout(() => {\r\n      fn.apply(this, args);\r\n    }, wait);\r\n  };\r\n}\r\n\r\n/**\r\n * Returns a promised function, that, as long as it continues to be invoked, will not be triggered.\r\n * The function will be called after it stops being called for N milliseconds.\r\n * Warning: does not work correctly for methods, use debounceMethodAsync() in that case.\r\n * @param {Function} fn   - original function\r\n * @param {number}   wait - number of milliseconds before the call\r\n * @return {Function}\r\n */\r\nexport function debounceAsync (fn, wait) {\r\n  let timeout    = 0;\r\n  const promises = [];\r\n  return function (...args) {\r\n    clearTimeout(timeout);\r\n    return new Promise((resolve, reject) => {\r\n      promises.push({resolve, reject});\r\n      timeout = setTimeout(() => {\r\n        try {\r\n          const res = fn.apply(this, args);\r\n          promises.forEach(p => p.resolve(res));\r\n        } catch (err) {\r\n          promises.forEach(p => p.reject(err));\r\n        }\r\n      }, wait);\r\n    });\r\n  };\r\n}\r\n\r\n/**\r\n * Returns a method, that, as long as it continues to be invoked, will not be triggered for\r\n * the same instance.\r\n * The method will be called after it stops being called for N milliseconds.\r\n * @param {function} fn   - original function\r\n * @param {number}   wait - number of milliseconds before the call\r\n * @return {function}\r\n */\r\nexport function debounceMethod (fn, wait) {\r\n  const prev = new WeakMap();\r\n  return function (...args) {\r\n    clearTimeout(prev.get(this));\r\n    prev.set(this, setTimeout(() => {\r\n      fn.apply(this, args);\r\n    }, wait));\r\n  };\r\n}\r\n\r\n/**\r\n * Returns an async method, that, as long as it continues to be invoked, will not be triggered.\r\n * The method will be called after it stops being called for N milliseconds.\r\n * @param {Function} fn   - original function\r\n * @param {number}   wait - number of milliseconds before the call\r\n * @return {Function}\r\n */\r\nexport function debounceMethodAsync (fn, wait) {\r\n  const instances = new WeakMap();\r\n  const promises  = [];\r\n  return function (...args) {\r\n    clearTimeout(instances.get(this));\r\n    return new Promise((resolve, reject) => {\r\n      promises.push({resolve, reject});\r\n      instances.set(this, setTimeout(() => {\r\n        try {\r\n          const res = fn.apply(this, args);\r\n          promises.forEach(p => p.resolve(res));\r\n        } catch (err) {\r\n          promises.forEach(p => p.reject(err));\r\n        } finally {\r\n          promises.length = 0;\r\n        }\r\n      }, wait));\r\n    })\r\n  };\r\n}\r\n\r\n/**\r\n * Returns a method, that, as long as it continues to be invoked, will not be triggered.\r\n * The method will be called after it stops being called for N milliseconds.\r\n * @param {Function} fn   - original function\r\n * @param {number}   wait - number of milliseconds before the call\r\n * @return {Function}\r\n */\r\nexport function debounceMethodParameter (fn, wait) {\r\n  const prev = new WeakMap();\r\n  return function (...args) {\r\n    if (prev.get(this)) {\r\n      clearTimeout(prev.get(this)[args[0]]);\r\n    } else {\r\n      prev.set(this, {});\r\n    }\r\n    prev.get(this)[args[0]] = setTimeout(() => {\r\n      delete prev.get(this)[args[0]];\r\n      fn.apply(this, args);\r\n    }, wait);\r\n  };\r\n}\r\n\r\n/**\r\n * Returns a function, that, as long as it continues to be invoked if the precCondition function\r\n * don't return true with the same arguments.\r\n * @param {Function} condition - pre condition function\r\n * @param {Function} fn        - original function\r\n * @return {Function}\r\n */\r\nexport function preCondition (condition, fn) {\r\n  return function (...args) {\r\n    if (condition.apply(this, args)) {\r\n      return fn.apply(this, args);\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Return a function that execute after the function is called.\r\n * @param {Function} fn  - original function\r\n * @param {Function} pos - function called after the original\r\n * @return {Function}\r\n */\r\nexport function posExecution (fn, pos) {\r\n  return function (...args) {\r\n    const result = fn.apply(this, args);\r\n    if (result instanceof Promise) {\r\n      return result.then((res) => {\r\n        return pos.call(this, res) || res\r\n      });\r\n    }\r\n    return pos.call(this, result) || result;\r\n  }\r\n}", "/**\r\n *\r\n * Base class for Graphane web component\r\n *\r\n * @module base\r\n * @version 0.0.2\r\n * @author Pablo Almunia\r\n *\r\n */\r\nimport {\r\n  Simple,\r\n  define as defineSimple,\r\n  CHANGE,\r\n  CONTEXT,\r\n  FIRE_EVENT,\r\n  COMPONENT_PREFIX\r\n} from './simple.js';\r\nimport {\r\n  isUndefined, isFunction, isNull, EMPTY_STRING,\r\n} from '../helpers/types.js';\r\nimport {\r\n  debounceMethodAsync, posExecution, preCondition\r\n} from '../helpers/functions.js';\r\n\r\n// Constants\r\nconst DELAY = 1;\r\n\r\n// Public symbols\r\n/**\r\n * Symbol used for defines the refresh method into the class inherited from Base.\r\n * This method is called when the component is rendered and when some property\r\n * is changed and REFRESH is defined as pos update action.\r\n * @type {symbol}\r\n */\r\nconst REFRESH   = Symbol();\r\n/**\r\n * Symbol used for defines the render method into the class inherited from Base\r\n * This method is called when the component is created and when some property\r\n * is changed and RENDER is define as pos update action.\r\n * @type {symbol}\r\n */\r\nconst RENDER    = Symbol();\r\n/**\r\n * Symbol used for defines the resize method into the class inherited from Base.\r\n * This method is called when the component is resized.\r\n * @type {symbol}\r\n */\r\nconst RESIZE    = Symbol();\r\n/**\r\n * Symbol used for defines the map with CSS properties info.\r\n * @type {symbol}\r\n */\r\nconst CSS_PROPS = Symbol();\r\n\r\n/**\r\n * Update an attribute into the HTML\r\n * @param {HTMLElement} element\r\n * @param {string} attribute\r\n * @param {any} value\r\n * @param {boolean} [asBoolean=false]\r\n * @returns {undefined}\r\n */\r\nfunction updateAttribute (element, attribute, value, asBoolean = false) {\r\n  if (element.ready === false || !attribute) {\r\n    return;\r\n  }\r\n  if (asBoolean) {\r\n    if (value) {\r\n      element.setAttribute(attribute, EMPTY_STRING);\r\n    } else {\r\n      element.removeAttribute(attribute);\r\n    }\r\n  } else {\r\n    const valueNormalized = isNull(value) || isUndefined(value) ? EMPTY_STRING : value.toString();\r\n    if (element.hasAttribute(attribute) && element.getAttribute(attribute) !== valueNormalized) {\r\n      element.setAttribute(attribute, valueNormalized);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Base class for Graphane Web Component\r\n *\r\n * @fires 'ready'                 - This event fires when the component is ready and its methods and properties are available\r\n * @fires 'render'                - This event fires when the component is rendered and its visible content is displayed\r\n * @fires 'refresh'               - This event fires when the component is refreshed, and its visible content is updated\r\n * @fires 'resize'                - This event fires when the component size is changed\r\n * @property {boolean} [ready]    - It's true if the component is ready, or false is starting or busy.\r\n * @property {boolean} [rendered] - It's true if the component is rendered, and its visible content is displayed.\r\n */\r\nclass Base extends Simple {\r\n\r\n  /**\r\n   * @constructor\r\n   * @param {boolean} [ready]\r\n   */\r\n  constructor (ready) {\r\n    super();\r\n\r\n    this.attachShadow({mode : 'open'});\r\n    this[CONTEXT].ready    = ready || false;\r\n    this[CONTEXT].rendered = false;\r\n\r\n    if (isUndefined(ready)) {\r\n      this.ready = true;\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * ready state\r\n   * @type {boolean}\r\n   */\r\n  get ready () {\r\n    return this[CONTEXT].ready;\r\n  }\r\n\r\n  set ready (value) {\r\n    const ctx = this[CONTEXT];\r\n    const pre = ctx.ready;\r\n    ctx.ready = !!value;\r\n    if (pre === false && ctx.ready === true) {\r\n      this[FIRE_EVENT]('ready', {ready : true});\r\n      if (isFunction(this[RENDER])) {\r\n        this[RENDER]();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * rendered state\r\n   * @returns {boolean}\r\n   */\r\n  get rendered () {\r\n    return this[CONTEXT].rendered;\r\n  }\r\n\r\n  set rendered (value) {\r\n    const ctx    = this[CONTEXT];\r\n    const pre    = ctx.rendered;\r\n    ctx.rendered = !!value;\r\n    if (pre === false && ctx.rendered === true) {\r\n      this[FIRE_EVENT]('render', {rendered : true});\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Connected with the parent DOM\r\n   *   - Resize observer\r\n   * @private\r\n   */\r\n  connectedCallback () {\r\n    let reference     = this.getBoundingClientRect();\r\n    let flexDirection = getComputedStyle(this).flexDirection; // Specific for Icon class\r\n    const resize      = () => {\r\n      let {width : currentWidth, height : currentHeight} = this.getBoundingClientRect();\r\n      let currentFlexDirection                           = getComputedStyle(this).flexDirection;\r\n      if (currentWidth !== reference.width || currentHeight !== reference.height || currentFlexDirection !== flexDirection) {\r\n        if (isFunction(this[RESIZE])) {\r\n          this[RESIZE](\r\n            currentWidth,\r\n            currentHeight,\r\n            currentWidth - reference.width,\r\n            currentHeight - reference.height\r\n          );\r\n        }\r\n        reference     = {width : currentWidth, height : currentHeight};\r\n        flexDirection = currentFlexDirection;\r\n        this[FIRE_EVENT]('resize', reference);\r\n      }\r\n      this [CONTEXT]._resizeObserver = window.requestAnimationFrame(resize);\r\n    };\r\n    resize();\r\n  }\r\n\r\n  /**\r\n   * Disconnected of parent DOM\r\n   *   - Remove resize observer\r\n   * @private\r\n   */\r\n  disconnectedCallback () {\r\n    window.cancelAnimationFrame(this [CONTEXT]._resizeObserver);\r\n  }\r\n\r\n}\r\n\r\n/**\r\n *\r\n * Property descriptor used into defineProperty\r\n *\r\n * @typedef {Object} cssPropertyDescriptor\r\n * @property {string}  name              - custom property name\r\n * @property {string}  [syntax='']       - syntax of the custom property\r\n * @property {string}  [initialValue=''] - initial value\r\n * @property {string}  [value='']        - initial value (alias)\r\n * @property {boolean} [inherits=false]  - inherit\r\n */\r\n\r\n/**\r\n *\r\n * Define a CSS property into the class\r\n *\r\n * @param {Function} Class            - class to extend\r\n * @param {cssPropertyDescriptor} def - options into a {@link cssPropertyDescriptor}\r\n */\r\nfunction defineStyleProperty (Class, def) {\r\n  const definition = {\r\n    name         : def.name.startsWith('--') ?\r\n      def.name :\r\n      `--${ COMPONENT_PREFIX }${ def.name }`,\r\n    initialValue : def.initialValue ?? def.value ?? '',\r\n    syntax       : def.syntax ?? '*',\r\n    inherits     : def.inherits ?? true\r\n  };\r\n  if (!Class.prototype[CSS_PROPS]) {\r\n    Class.prototype[CSS_PROPS] = {};\r\n  }\r\n  Class.prototype[CSS_PROPS][definition.name] = definition;\r\n}\r\n\r\n/**\r\n *\r\n * Define a Component\r\n *\r\n * @param {Function} Class - Class for this custom component\r\n */\r\nfunction defineComponent (Class) {\r\n\r\n  // Async call to render method\r\n  if (isFunction(Class.prototype[RENDER])) {\r\n    const preRender         = Class.prototype[RENDER];\r\n    Class.prototype[RENDER] =\r\n      preCondition(\r\n        function () {\r\n          this.rendered = false;\r\n          return this.ready;\r\n        },\r\n        debounceMethodAsync(\r\n          posExecution(\r\n            async function () {\r\n              return preRender.apply(this);\r\n            },\r\n            function (result) {\r\n              this.rendered = result !== false;\r\n              if (this.rendered && isFunction(this[REFRESH])) {\r\n                this[REFRESH]();\r\n              }\r\n            }\r\n          ),\r\n          DELAY\r\n        )\r\n      );\r\n  }\r\n\r\n  // Async call to refresh method\r\n  if (isFunction(Class.prototype[REFRESH])) {\r\n    const prevRefresh        = Class.prototype[REFRESH];\r\n    Class.prototype[REFRESH] =\r\n      preCondition(\r\n        function (force) {\r\n          if (force) {\r\n            this[CONTEXT].rendered = true;\r\n          }\r\n          return this.ready && this[CONTEXT].rendered;\r\n        },\r\n        debounceMethodAsync(\r\n          posExecution(\r\n            async function (...args) {\r\n              return prevRefresh.apply(this, args);\r\n            },\r\n            function () {\r\n              this[FIRE_EVENT]('refresh');\r\n            }\r\n          ),\r\n          DELAY\r\n        )\r\n      );\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * Define a Base or\r\n * @param {Function} Class\r\n * @returns {object}\r\n */\r\nfunction define (Class) {\r\n  defineComponent(Class);\r\n  const def = defineSimple(Class, {\r\n    style : (...styles) => {\r\n      styles.forEach(style => defineStyleProperty(Class, {...style}));\r\n      return def;\r\n    }\r\n  });\r\n  return def;\r\n}\r\n\r\nBase.RENDER  = RENDER;\r\nBase.REFRESH = REFRESH;\r\nBase.CHANGE  = CHANGE;\r\n\r\n/**\r\n * Export\r\n */\r\nexport {\r\n  Base as default,\r\n  Base,\r\n  Simple,\r\n  define,\r\n  RENDER,\r\n  REFRESH,\r\n  CHANGE,\r\n  CONTEXT,\r\n  RESIZE,\r\n  CSS_PROPS,\r\n  FIRE_EVENT,\r\n  COMPONENT_PREFIX\r\n};\r\n", "import { CSS_PROPS, COMPONENT_PREFIX } from './base.js';\r\n\r\nconst buildName   = (name) => name.startsWith('--') ? name : `--${ COMPONENT_PREFIX }${ name }`;\r\n\r\n\r\n/**\r\n * Get a CSS Property Value (current or default value)\r\n * @param {Element}       component  - Object from a class inherited from Base\r\n * @param {Map}           cssProps   - Map with CSS Properties\r\n * @param {string|Object} name       - CSS property name or CSS property descriptor\r\n * @returns {*}                      - Current CSS property value\r\n */\r\nexport function getCSSPropertyValue (component, cssProps, name) {\r\n  name         = typeof name === 'object' ? name.name : name;\r\n  const result = getComputedStyle(component).getPropertyValue(name);\r\n  if ((typeof result === 'undefined' || result === '') &&\r\n      cssProps &&\r\n      cssProps.hasOwnProperty(name)) {\r\n    return cssProps[name].value;\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Get the list of CSS Property Descriptors\r\n * @param {Object} component - Object from a class inherited from Base\r\n * @returns {Map}            - List of CSS properties\r\n */\r\nexport function getCSSPropertyDescriptors (component) {\r\n  return component[CSS_PROPS] || {};\r\n}\r\n\r\n/**\r\n * Get the list of CSS Properties\r\n * @param {Object} component - Object from a class inherited from Base\r\n * @returns {array<string>}  - List of CSS property keys accepted by that component\r\n */\r\nexport function getCSSProperties (component) {\r\n  return Object.keys(getCSSPropertyDescriptors(component));\r\n}\r\n\r\n/**\r\n * Get a CSS Properties descriptor\r\n * @param {Object}        component - Object from a class inherited from Base\r\n * @param {string|Object} name      - CSS property name or CSS property descriptor\r\n * @returns {object}                - Return a CSS property descriptor\r\n */\r\nexport function getCSSProperty (component, name) {\r\n  const cssProps = getCSSPropertyDescriptors(component);\r\n  name           = buildName(typeof name === 'object' ? name.name : name);\r\n  return cssProps[name];\r\n}\r\n\r\n/**\r\n * Return a valid \"var()\" string with all CSS properties passed as parameters\r\n * @param {Object}        component - Object from a class inherited from Base\r\n * @param {string|object} name      - CSS property name or CSS property descriptor\r\n * @returns {string}                - \"var()\" string\r\n */\r\nexport function getCSSVar (component, ...name) {\r\n  let result       = '';\r\n  let defaultValue = '';\r\n  for (let i = 0; i < name.length; i++) {\r\n    const property = getCSSProperty(component, name[i]);\r\n    result += `${ result ? ', ' : '' } var(${ buildName(property?.name || name[i]) }`;\r\n    defaultValue = property?.initialValue;\r\n  }\r\n  if (defaultValue) {\r\n    result += `, ${ defaultValue }`;\r\n  }\r\n  result += ')'.repeat(name.length);\r\n  return result;\r\n}\r\n\r\n", "import { CONTEXT, FIRE_EVENT } from \"./base.js\";\r\nimport { STRING, NUMBER }      from '../helpers/types.js';\r\n\r\nconst EVENT_IN  = 'enterViewport';\r\nconst EVENT_OUT = 'exitViewport';\r\nconst OBSERVER  = Symbol();\r\nconst options   = {\r\n  \"root\"       : null,\r\n  \"rootMargin\" : \"0px\",\r\n  \"threshold\"  : [0, 0.5, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1]\r\n};\r\n\r\nexport function viewport (defineObject) {\r\n  defineObject\r\n    .attribute({name : 'viewport-once-class', type : STRING, value : '', posUpdate : observer})\r\n    .attribute({name : 'viewport-class', type : STRING, value : '', posUpdate : observer})\r\n    .attribute({name : 'viewport-ratio', type : NUMBER, value : 0, posUpdate : observer})\r\n}\r\n\r\nfunction add (classList, classes) {\r\n  if (classes) {\r\n    classes.split(' ').forEach(cl => classList.add(cl));\r\n  }\r\n}\r\n\r\nfunction remove (classList, classes) {\r\n  if (classes) {\r\n    classes.split(' ').forEach(cl => classList.remove(cl));\r\n  }\r\n}\r\n\r\nfunction observer () {\r\n  const ctx       = this [CONTEXT];\r\n  const classList = this.classList;\r\n  let intersected = false;\r\n  if (this[OBSERVER]) {\r\n    this[OBSERVER].disconnect();\r\n  }\r\n  this[OBSERVER] = new IntersectionObserver(entries => {\r\n    entries.forEach(entry => {\r\n      if (entry.isIntersecting && entry.intersectionRatio >= ctx.viewportRatio) {\r\n        if (!intersected) {\r\n          add(classList, ctx.viewportOnceClass);\r\n          add(classList, ctx.viewportClass);\r\n          intersected = true;\r\n          this[FIRE_EVENT](EVENT_IN);\r\n        }\r\n      } else if (intersected) {\r\n        remove(classList, ctx.viewportClass);\r\n        intersected = false;\r\n        this[FIRE_EVENT](EVENT_OUT);\r\n      }\r\n    });\r\n  }, options);\r\n  this[OBSERVER].observe(this);\r\n}\r\n\r\n\r\nexport default viewport;\r\n"],
  "mappings": "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",
  "names": ["FUNCTION", "UNDEFINED", "OBJECT", "STRING", "ARRAY", "NUMBER", "BOOLEAN", "DATE", "EMPTY_STRING", "isObject", "v", "OBJECT", "isString", "STRING", "isFunction", "FUNCTION", "isUndefined", "v", "UNDEFINED", "isArray", "v", "isDate", "isNull", "toCamel", "name", "x", "y", "attribute2object", "value", "isString", "normalized", "partial", "str2value", "err", "isObject", "attribute2array", "arr", "str", "isArray", "str2value", "str", "type", "quote", "isString", "removeDoubleQuote", "ARRAY", "attribute2array", "OBJECT", "attribute2object", "isUndefined", "NUMBER", "value", "BOOLEAN", "DATE", "STRING", "cache", "ignore", "objectObserver", "object", "callback", "isFunction", "observe", "obj", "prop", "isObject", "isNull", "result", "target", "value", "isDate", "isString", "args", "ret", "same", "object_observer_default", "NOT_EQUAL", "EQUAL", "createOther", "obj", "clone", "isObject", "copy", "p", "equal", "objectA", "objectB", "aStack", "bStack", "checkObject", "a", "b", "isFunction", "aKeys", "bKeys", "i", "key", "check", "aType", "NUMBER", "OBJECT", "COMPONENT_PREFIX", "INITIALIZERS", "CONTEXT", "CHANGE", "FIRE_EVENT", "defProp", "updateAttribute", "element", "attribute", "value", "asBoolean", "EMPTY_STRING", "valueNormalized", "isNull", "isUndefined", "initValues", "target", "proto", "init", "initialValues", "p", "tmp", "clone", "observeMutation", "mutations", "mutation", "isFunction", "Simple", "fn", "event", "detail", "composed", "defineAttribute", "Class", "toCamel", "defineProperty", "prototype", "OBSERVE_ATTRIBUTES", "descriptorObsAttr", "descriptorObsAttrPrototype", "previousGet", "descriptorObservedAttributes", "ATTRIBUTE_CHANGED_CALLBACK", "descriptorAttrChgCbk", "descriptorAttrChgCbkPrototype", "previousFunction", "defineAttributeDescriptor", "name", "oldValue", "propertyName", "BOOLEAN", "str2value", "descriptor", "property", "definePropertySet", "definePropertyGet", "pos", "ctx", "object_observer_default", "isObject", "equal", "isString", "ARRAY", "OBJECT", "NUMBER", "obj", "registreComponent", "define", "def", "properties", "attributes", "debounceMethodAsync", "fn", "wait", "instances", "promises", "args", "resolve", "reject", "res", "p", "err", "preCondition", "condition", "fn", "args", "posExecution", "pos", "result", "res", "DELAY", "REFRESH", "RENDER", "RESIZE", "CSS_PROPS", "Base", "Simple", "ready", "CONTEXT", "isUndefined", "value", "ctx", "pre", "FIRE_EVENT", "isFunction", "RENDER", "reference", "flexDirection", "resize", "currentWidth", "currentHeight", "currentFlexDirection", "RESIZE", "defineStyleProperty", "Class", "def", "definition", "COMPONENT_PREFIX", "CSS_PROPS", "defineComponent", "preRender", "preCondition", "debounceMethodAsync", "posExecution", "result", "REFRESH", "DELAY", "prevRefresh", "force", "args", "define", "styles", "style", "CHANGE", "buildName", "name", "COMPONENT_PREFIX", "getCSSPropertyValue", "component", "cssProps", "result", "getCSSPropertyDescriptors", "CSS_PROPS", "getCSSProperties", "getCSSProperty", "getCSSVar", "defaultValue", "i", "property", "EVENT_IN", "EVENT_OUT", "OBSERVER", "options", "viewport", "defineObject", "STRING", "observer", "NUMBER", "add", "classList", "classes", "cl", "remove", "ctx", "CONTEXT", "intersected", "entries", "entry", "FIRE_EVENT"]
}
