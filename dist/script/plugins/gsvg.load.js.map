{
  "version": 3,
  "sources": ["../../../src/helpers/types.js", "../../../src/plugins/load.js"],
  "sourcesContent": ["export const FUNCTION  = 'function';\r\nexport const UNDEFINED = 'undefined';\r\nexport const OBJECT    = 'object';\r\nexport const STRING    = 'string';\r\nexport const ARRAY     = 'array';\r\nexport const NUMBER    = 'number';\r\nexport const BOOLEAN   = 'boolean';\r\nexport const DATE      = 'date';\r\nexport const SYMBOL    = 'symbol';\r\n\r\nexport const EMPTY_STRING = '';\r\nexport const COMA         = ',';\r\nexport const COLON        = ':';\r\nexport const SEMICOLON    = ';';\r\n\r\nexport const isObject    = (v) => typeof v === OBJECT;\r\nexport const isString    = (v) => typeof v === STRING;\r\nexport const isFunction  = (v) => typeof v === FUNCTION;\r\nexport const isNumber    = (v) => typeof v === NUMBER && !isNaN(v);\r\nexport const isUndefined = (v) => typeof v === UNDEFINED;\r\nexport const isSymbol    = (v) => typeof v === SYMBOL;\r\nexport const isBoolean   = (v) => typeof v === BOOLEAN;\r\nexport const isArray     = (v) => Array.isArray(v);\r\nexport const isDate      = (v) => v instanceof Date && !isNaN(v);\r\nexport const isNull      = (v) => v === null;\r\n\r\n/**\r\n * Convert attribute name to camel property name\r\n * @param {string} name\r\n * @return {string}\r\n */\r\nexport const toCamel = name => name.replace(/-([a-z0-9])/g, (x, y) => y.toUpperCase());\r\n\r\n/**\r\n * Converto property name to hyphen attribute name\r\n * @param {string} name\r\n * @return {string}\r\n */\r\nexport const toHyphen = name => {\r\n  name = name.replace(/([A-Z])/g, '-$1').toLowerCase();\r\n  return name.startsWith('-') ? name.slice(1) : name;\r\n};\r\n\r\n\r\n/**\r\n * Convert an object property to an attribute string\r\n * @param {Object} value\r\n * @return {string|undefined}\r\n */\r\nexport function object2attribute (value) {\r\n  if (isObject(value)) {\r\n    let str = '';\r\n    for (let key of Object.keys(value)) {\r\n      str += `${ str ? '; ' : '' }${ key }: ${ value[key] }`;\r\n    }\r\n    return str;\r\n  } else if (isString(value)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Convert an attribute string to an object property\r\n * @param {string} value\r\n * @return {Object|undefined}\r\n */\r\nexport function attribute2object (value) {\r\n  if (isString(value)) {\r\n    try {\r\n      const normalized = value\r\n        .replace(/^\\s*{/, '')\r\n        .replace(/}\\s*$/, '')\r\n        .split(/((?:[^;^,\"']|\"[^\"]*\"|'[^']*')+)/)\r\n        .filter(partial => !['', ';', ','].includes(partial.trim()))\r\n        .map(partial => partial.split(':'))\r\n        .map(partial => `\"${ partial[0].trim() }\":${ str2value(\r\n          partial[1].trim(),\r\n          undefined,\r\n          true\r\n        ) }`)\r\n        .join(',');\r\n      return JSON.parse(`{${ normalized }}`);\r\n    } catch (err) {\r\n      console.error(err);\r\n      return undefined;\r\n    }\r\n  } else if (isObject(value)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Convert an attribute string to an array\r\n * @param {string} value\r\n * @return {Object|undefined}\r\n */\r\nexport function attribute2array (value) {\r\n  if (isString(value)) {\r\n    if (value.trim().startsWith('[')) {\r\n      return (value.match(/\\[(.*?)[^\\]]]/g) || []).map(arr => attribute2array(arr.substring(\r\n        1,\r\n        arr.length - 1\r\n      )));\r\n    } else {\r\n      return value.split(/[,;]/).map(str => str2value(str.trim()));\r\n    }\r\n  } else if (isArray(value)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Convert an attribute string to an array of objects\r\n * @param {string} value\r\n * @return {Object|undefined}\r\n */\r\nexport function attribute2arrayObject (value) {\r\n  if (isString(value)) {\r\n    if (value.trim().startsWith('[')) {\r\n      return (value.match(/\\[(.*?)[^\\]]]/g) || []).map(arr => attribute2object(arr.substring(\r\n        1,\r\n        arr.length - 1\r\n      )));\r\n    } else {\r\n      return [attribute2object(value)];\r\n    }\r\n  } else if (isArray(Array)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n\r\n/**\r\n *\r\n * @param {Object|string} value\r\n * @return {string|undefined}\r\n */\r\nexport function array2attribute (value) {\r\n  if (isArray(value)) {\r\n    let str = JSON.stringify(value);\r\n    return str.substring(1, str.length - 1)\r\n              .replace(/,/g, ', ')\r\n              .replace(/\"/g, '');\r\n  } else if (isString(value)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Convert a string into a value number, boolean or string (with \"\" if quote is true)\r\n * @private\r\n * @param {string} str\r\n * @param {string} [type]\r\n * @param {boolean} [quote=false]\r\n * @return {any}\r\n */\r\nexport function str2value (str, type, quote = false) {\r\n  if (!isString(str)) {\r\n    return str;\r\n  }\r\n  str = removeDoubleQuote(str.trim());\r\n  if (type === ARRAY) {\r\n    return attribute2array(str);\r\n  }\r\n  if (type === OBJECT) {\r\n    return attribute2object(str);\r\n  }\r\n  if (isUndefined(type) || type === NUMBER) {\r\n    if (isUndefined(str) || str === '') {\r\n      return undefined;\r\n    }\r\n    let value = +str;\r\n    if (!Number.isNaN(value) || type === NUMBER) {\r\n      return value;\r\n    }\r\n  }\r\n  if (isUndefined(type) || type === BOOLEAN) {\r\n    if (str === 'true') {\r\n      return true;\r\n    } else if (str === 'false') {\r\n      return false;\r\n    }\r\n    if (type === BOOLEAN) {\r\n      if (str === '0') {\r\n        return false;\r\n      }\r\n      return !!str;\r\n    }\r\n  }\r\n  if (type === DATE) {\r\n    try {\r\n      let value = new Date(str);\r\n      if (!Number.isNaN(value.getTime())) {\r\n        return value;\r\n      }\r\n    } catch (e) {\r\n      void (0);\r\n    }\r\n    return undefined;\r\n  }\r\n  if (isUndefined(type) || type === STRING) {\r\n    return quote ? `\"${ str }\"` : str;\r\n  }\r\n}\r\n\r\nfunction removeDoubleQuote (str) {\r\n  if (\r\n    (str[0] === '\\'' && str[str.length - 1] === '\\'') ||\r\n    (str[0] === '\"' && str[str.length - 1] === '\"')\r\n  ) {\r\n    return str.substring(1, str.length - 1);\r\n  }\r\n  return str;\r\n}\r\n\r\n/**\r\n *\r\n * @param {string} str\r\n * @returns {boolean}\r\n */\r\nexport function isLikeObject (str) {\r\n  return /^\\s*{(.|\\s)*}\\s*$/.test(str);\r\n}\r\n\r\n/**\r\n *\r\n * @param {string} str\r\n * @returns {boolean}\r\n */\r\nexport function isLikeArray (str) {\r\n  return /^\\s*\\[(.|\\s)*]\\s*$/.test(str);\r\n}\r\n\r\n\r\nexport function csvStr2obj (str) {\r\n  let keys = [];\r\n  return str\r\n    .split(/(\\r\\n|\\r|\\n)/)\r\n    .map(r => r.trim())\r\n    .filter(r => r)\r\n    .reduce(\r\n      (result, row, idx) => {\r\n        const obj   = {};\r\n        const parts = row\r\n          .split(/((?:[^;^,\"']|\"[^\"]*\"|'[^']*')+)/)\r\n          .filter(partial => ![EMPTY_STRING, SEMICOLON, COMA].includes(partial.trim()));\r\n        if (idx === 0) {\r\n          keys = [...parts.map(x => str2value(x))];\r\n          return result;\r\n        }\r\n        parts.forEach((part, i) => {\r\n          obj[keys[i]] = str2value(part);\r\n        });\r\n        result.push(obj);\r\n        return result;\r\n      },\r\n      []\r\n    );\r\n}\r\n\r\nexport function jsStr2obj (str) {\r\n  const code = `return (${ str });`\r\n  const ret  = (new Function(code))();\r\n  return typeof ret === 'function' ? ret() : ret;\r\n}\r\n\r\nexport function funcStr2obj (str, $) {\r\n  return (new Function('$', `${ str };let ___$$$ret = {};${\r\n    [...str.matchAll(/\\s*function\\s*(\\w+)/gm)]\r\n      .map(x => `if (typeof ${ x[1] } === 'function') ___$$$ret.${ x[1] } = ${ x[1] };`)\r\n      .join('')\r\n  } return ___$$$ret;`))($);\r\n}", "import { isFunction } from \"../helpers/types.js\";\r\n\r\nconst cache = {};\r\n\r\nconst getSVG = async (gObject, src) => {\r\n  if (!cache[src]) {\r\n    const res = await fetch(src);\r\n    if (res.status === 200) {\r\n      cache[src] = await res.text();\r\n    }\r\n  }\r\n  if (cache[src]) {\r\n    gObject.content(cache[src]);\r\n    return gObject.querySelector('svg');\r\n  }\r\n  return null;\r\n}\r\n\r\nconst delayExecution = (src) => {\r\n  const commands = [];\r\n  const proxy    = new Proxy(\r\n    function () {\r\n      return commands;\r\n    },\r\n    {\r\n      get (target, command) {\r\n        if (command === Symbol.toPrimitive) {\r\n          return () => src;\r\n        }\r\n        if (command === 'then') {\r\n          return (resolve) => resolve(proxy);\r\n        }\r\n        return (...args) => {\r\n          commands.push({command, args});\r\n          return proxy;\r\n        }\r\n      }\r\n    }\r\n  )\r\n  return proxy;\r\n}\r\n\r\nexport function svgPlugin (setup) {\r\n  if (setup.extendTemplate) {\r\n    setup.extendTemplate.defineDirective({\r\n      name : 'g-load',\r\n      execute (gObject, {expression, evalExpression, data}) {\r\n        const context = {\r\n          ...data,\r\n          $$ : {\r\n            svg (source) {\r\n              return delayExecution(source);\r\n            }\r\n          }\r\n        };\r\n        const res     = evalExpression(expression, context);\r\n        getSVG(gObject, res).then(svg => {\r\n          if (svg) {\r\n            if (isFunction(res)) {\r\n              const commands = res();\r\n              commands.forEach(step => {\r\n                svg[step.command](step.args);\r\n              })\r\n            }\r\n          }\r\n          gObject.dispatchEvent(new Event('load', {bubbles: true}));\r\n        });\r\n      }\r\n    });\r\n  }\r\n}"],
  "mappings": "AAAO,IAAMA,EAAY,WAiBlB,IAAMC,EAAeC,GAAM,OAAOA,IAAMC,ECf/C,IAAMC,EAAQ,CAAC,EAETC,EAAS,MAAOC,EAASC,IAAQ,CACrC,GAAI,CAACH,EAAMG,CAAG,EAAG,CACf,IAAMC,EAAM,MAAM,MAAMD,CAAG,EACvBC,EAAI,SAAW,MACjBJ,EAAMG,CAAG,EAAI,MAAMC,EAAI,KAAK,EAEhC,CACA,OAAIJ,EAAMG,CAAG,GACXD,EAAQ,QAAQF,EAAMG,CAAG,CAAC,EACnBD,EAAQ,cAAc,KAAK,GAE7B,IACT,EAEMG,EAAkBF,GAAQ,CAC9B,IAAMG,EAAW,CAAC,EACZC,EAAW,IAAI,MACnB,UAAY,CACV,OAAOD,CACT,EACA,CACE,IAAKE,EAAQC,EAAS,CACpB,OAAIA,IAAY,OAAO,YACd,IAAMN,EAEXM,IAAY,OACNC,GAAYA,EAAQH,CAAK,EAE5B,IAAII,KACTL,EAAS,KAAK,CAAC,QAAAG,EAAS,KAAAE,CAAI,CAAC,EACtBJ,EAEX,CACF,CACF,EACA,OAAOA,CACT,EAEO,SAASK,EAAWC,EAAO,CAC5BA,EAAM,gBACRA,EAAM,eAAe,gBAAgB,CACnC,KAAO,SACP,QAASX,EAAS,CAAC,WAAAY,EAAY,eAAAC,EAAgB,KAAAC,CAAI,EAAG,CACpD,IAAMC,EAAU,CACd,GAAGD,EACH,GAAK,CACH,IAAKE,EAAQ,CACX,OAAOb,EAAea,CAAM,CAC9B,CACF,CACF,EACMd,EAAUW,EAAeD,EAAYG,CAAO,EAClDhB,EAAOC,EAASE,CAAG,EAAE,KAAKe,GAAO,CAC3BA,GACEC,EAAWhB,CAAG,GACCA,EAAI,EACZ,QAAQiB,GAAQ,CACvBF,EAAIE,EAAK,OAAO,EAAEA,EAAK,IAAI,CAC7B,CAAC,EAGLnB,EAAQ,cAAc,IAAI,MAAM,OAAQ,CAAC,QAAS,EAAI,CAAC,CAAC,CAC1D,CAAC,CACH,CACF,CAAC,CAEL",
  "names": ["FUNCTION", "isFunction", "v", "FUNCTION", "cache", "getSVG", "gObject", "src", "res", "delayExecution", "commands", "proxy", "target", "command", "resolve", "args", "svgPlugin", "setup", "expression", "evalExpression", "data", "context", "source", "svg", "isFunction", "step"]
}
