{
  "version": 3,
  "sources": ["../../../src/helpers/types.js", "../../../src/helpers/function.create.js", "../../../src/helpers/identifier.js", "../../../src/plugins/animateto.js", "../../../src/plugins/template.engine.js"],
  "sourcesContent": ["export const FUNCTION  = 'function';\r\nexport const UNDEFINED = 'undefined';\r\nexport const OBJECT    = 'object';\r\nexport const STRING    = 'string';\r\nexport const ARRAY     = 'array';\r\nexport const NUMBER    = 'number';\r\nexport const BOOLEAN   = 'boolean';\r\nexport const DATE      = 'date';\r\nexport const SYMBOL    = 'symbol';\r\n\r\nexport const EMPTY_STRING = '';\r\nexport const COMA         = ',';\r\nexport const COLON        = ':';\r\nexport const SEMICOLON    = ';';\r\n\r\nexport const isObject    = (v) => typeof v === OBJECT;\r\nexport const isString    = (v) => typeof v === STRING;\r\nexport const isFunction  = (v) => typeof v === FUNCTION;\r\nexport const isNumber    = (v) => typeof v === NUMBER && !isNaN(v);\r\nexport const isUndefined = (v) => typeof v === UNDEFINED;\r\nexport const isSymbol    = (v) => typeof v === SYMBOL;\r\nexport const isBoolean   = (v) => typeof v === BOOLEAN;\r\nexport const isArray     = (v) => Array.isArray(v);\r\nexport const isDate      = (v) => v instanceof Date && !isNaN(v);\r\nexport const isNull      = (v) => v === null;\r\n\r\n/**\r\n * Convert attribute name to camel property name\r\n * @param {string} name\r\n * @return {string}\r\n */\r\nexport const toCamel = name => name.replace(/-([a-z0-9])/g, (x, y) => y.toUpperCase());\r\n\r\n/**\r\n * Converto property name to hyphen attribute name\r\n * @param {string} name\r\n * @return {string}\r\n */\r\nexport const toHyphen = name => {\r\n  name = name.replace(/([A-Z])/g, '-$1').toLowerCase();\r\n  return name.startsWith('-') ? name.slice(1) : name;\r\n};\r\n\r\n\r\n/**\r\n * Convert an object property to an attribute string\r\n * @param {Object} value\r\n * @return {string|undefined}\r\n */\r\nexport function object2attribute (value) {\r\n  if (isObject(value)) {\r\n    let str = '';\r\n    for (let key of Object.keys(value)) {\r\n      str += `${ str ? '; ' : '' }${ key }: ${ value[key] }`;\r\n    }\r\n    return str;\r\n  } else if (isString(value)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Convert an attribute string to an object property\r\n * @param {string} value\r\n * @return {Object|undefined}\r\n */\r\nexport function attribute2object (value) {\r\n  if (isString(value)) {\r\n    try {\r\n      const normalized = value\r\n        .replace(/^\\s*{/,'')\r\n        .replace(/}\\s*$/,'')\r\n        .split(/((?:[^;^,\"']|\"[^\"]*\"|'[^']*')+)/)\r\n        .filter(partial => !['', ';', ','].includes(partial.trim()))\r\n        .map(partial => partial.split(':'))\r\n        .map(partial => `\"${ partial[0].trim() }\":${ str2value(\r\n          partial[1].trim(),\r\n          undefined,\r\n          true\r\n        ) }`)\r\n        .join(',');\r\n      return JSON.parse(`{${ normalized }}`);\r\n    } catch (err) {\r\n      console.error(err);\r\n      return undefined;\r\n    }\r\n  } else if (isObject(value)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Convert an attribute string to an array\r\n * @param {string} value\r\n * @return {Object|undefined}\r\n */\r\nexport function attribute2array (value) {\r\n  if (isString(value)) {\r\n    if (value.trim().startsWith('[')) {\r\n      return (value.match(/\\[(.*?)[^\\]]]/g) || []).map(arr => attribute2array(arr.substring(\r\n        1,\r\n        arr.length - 1\r\n      )));\r\n    } else {\r\n      return value.split(/[,;]/).map(str => str2value(str.trim()));\r\n    }\r\n  } else if (isArray(value)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Convert an attribute string to an array of objects\r\n * @param {string} value\r\n * @return {Object|undefined}\r\n */\r\nexport function attribute2arrayObject (value) {\r\n  if (isString(value)) {\r\n    if (value.trim().startsWith('[')) {\r\n      return (value.match(/\\[(.*?)[^\\]]]/g) || []).map(arr => attribute2object(arr.substring(\r\n        1,\r\n        arr.length - 1\r\n      )));\r\n    } else {\r\n      return [attribute2object(value)];\r\n    }\r\n  } else if (isArray(Array)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n\r\n/**\r\n *\r\n * @param {Object|string} value\r\n * @return {string|undefined}\r\n */\r\nexport function array2attribute (value) {\r\n  if (isArray(value)) {\r\n    let str = JSON.stringify(value);\r\n    return str.substring(1, str.length - 1)\r\n              .replace(/,/g, ', ')\r\n              .replace(/\"/g, '');\r\n  } else if (isString(value)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Convert a string into a value number, boolean or string (with \"\" if quote is true)\r\n * @private\r\n * @param {string} str\r\n * @param {string} [type]\r\n * @param {boolean} [quote=false]\r\n * @return {any}\r\n */\r\nexport function str2value (str, type, quote = false) {\r\n  if (!isString(str)) {\r\n    return str;\r\n  }\r\n  str = removeDoubleQuote(str.trim());\r\n  if (type === ARRAY) {\r\n    return attribute2array(str);\r\n  }\r\n  if (type === OBJECT) {\r\n    return attribute2object(str);\r\n  }\r\n  if (isUndefined(type) || type === NUMBER) {\r\n    if (isUndefined(str) || str === '') {\r\n      return undefined;\r\n    }\r\n    let value = +str;\r\n    if (!Number.isNaN(value) || type === NUMBER) {\r\n      return value;\r\n    }\r\n  }\r\n  if (isUndefined(type) || type === BOOLEAN) {\r\n    if (str === 'true') {\r\n      return true;\r\n    } else if (str === 'false') {\r\n      return false;\r\n    }\r\n    if (type === BOOLEAN) {\r\n      if (str === '0') {\r\n        return false;\r\n      }\r\n      return !!str;\r\n    }\r\n  }\r\n  if (type === DATE) {\r\n    try {\r\n      let value = new Date(str);\r\n      if (!Number.isNaN(value.getTime())) {\r\n        return value;\r\n      }\r\n    } catch (e) {\r\n      void (0);\r\n    }\r\n    return undefined;\r\n  }\r\n  if (isUndefined(type) || type === STRING) {\r\n    return quote ? `\"${ str }\"` : str;\r\n  }\r\n}\r\n\r\nfunction removeDoubleQuote (str) {\r\n  if (\r\n    (str[0] === '\\'' && str[str.length - 1] === '\\'') ||\r\n    (str[0] === '\"' && str[str.length - 1] === '\"')\r\n  ) {\r\n    return str.substring(1, str.length - 1);\r\n  }\r\n  return str;\r\n}\r\n\r\n/**\r\n *\r\n * @param {string} str\r\n * @returns {boolean}\r\n */\r\nexport function isLikeObject(str) {\r\n  return /^\\s*{(.|\\s)*}\\s*$/.test(str);\r\n}\r\n\r\n/**\r\n *\r\n * @param {string} str\r\n * @returns {boolean}\r\n */\r\nexport function isLikeArray(str) {\r\n  return /^\\s*\\[(.|\\s)*]\\s*$/.test(str);\r\n}\r\n\r\n\r\nexport function csvStr2obj (str) {\r\n  let keys = [];\r\n  return str\r\n    .split(/(\\r\\n|\\r|\\n)/)\r\n    .map(r => r.trim())\r\n    .filter(r => r)\r\n    .reduce(\r\n      (result, row, idx) => {\r\n        const obj   = {};\r\n        const parts = row\r\n          .split(/((?:[^;^,\"']|\"[^\"]*\"|'[^']*')+)/)\r\n          .filter(partial => ![EMPTY_STRING, SEMICOLON, COMA].includes(partial.trim()));\r\n        if (idx === 0) {\r\n          keys = [...parts.map(p => JSON.parse(p))];\r\n          return result;\r\n        }\r\n        parts.forEach((part, i) => {\r\n          obj[keys[i]] = JSON.parse(part);\r\n        });\r\n        result.push(obj);\r\n        return result;\r\n      },\r\n      []\r\n    );\r\n}\r\n\r\nexport function jsStr2obj (str) {\r\n  const code = `return (${ str });`\r\n  const ret  = (new Function(code))();\r\n  return typeof ret === 'function' ? ret() : ret;\r\n}\r\n\r\nexport function funcStr2obj (str, $) {\r\n  return (new Function('$', `${ str };let ___$$$ret = {};${\r\n    [...str.matchAll(/\\s*function\\s*(\\w+)/gm)]\r\n      .map(x => `if (typeof ${ x[1] } === 'function') ___$$$ret.${ x[1] } = ${ x[1] };`)\r\n      .join('')\r\n  } return ___$$$ret;`))($);\r\n}", "const cache         = new Map();\r\nconst functionName  = /function\\s+([\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}]*)\\s*\\(/gmu;\r\nconst AsyncFunction = (async function () {\r\n}).constructor;\r\n\r\nexport function createFunction (args, code, async = false) {\r\n  const key = `${ args.join(',') } ${ code }`;\r\n  if (cache.has(key)) {\r\n    return cache.get(key);\r\n  }\r\n  const fn = new (async ? AsyncFunction : Function)(...args, code);\r\n  cache.set(key, fn);\r\n  return fn;\r\n}\r\n\r\n\r\nexport function getFunctions (globals, code) {\r\n  const names = [...code.matchAll(functionName)].map(x => x[1]);\r\n  try {\r\n    const fn = createFunction(Object.keys(globals), `${ code };\r\n  \r\n    return {${ names.map(n => `${ n }: typeof ${ n } === 'function' ? ${ n } : undefined`) }};\r\n  `);\r\n    return fn(...Object.values(globals));\r\n  } catch (err) {\r\n    console.warn(err.message, '\\n', code);\r\n  }\r\n}", "export function isValidIdentifier(identifier) {\r\n  try {\r\n    new Function(`const ${identifier} = 0`);\r\n    return true;\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n}", "import { isObject, isString, isFunction, isArray } from '../helpers/types.js';\r\n\r\nconst SVG       = 'SVG';\r\nconst ANIMATE   = 'animate';\r\nconst FILL      = 'none';\r\nconst FREEZE    = 'freeze';\r\nconst PATH      = 'path';\r\nconst D         = 'd';\r\nconst TRANSFORM = 'transform';\r\nconst ROTATE    = 'rotate';\r\nconst TRANSLATE = 'translate';\r\nconst OFFSET    = 'offset';\r\nconst INHERIT   = 'inherit';\r\nconst FINISHED  = 'finished';\r\nconst DEG_TYPES = [ROTATE, 'skewX', 'skewY'];\r\nconst DEG       = 'deg';\r\nconst PX        = 'px';\r\nconst MS        = 'ms';\r\nconst exception = ['width', 'height'];\r\n\r\n/**\r\n * The reduced-motion flag\r\n * @type {boolean}\r\n */\r\nlet reduceMotion = false;\r\nif (window.matchMedia) {\r\n  const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\r\n  reduceMotion     = mediaQuery.matches;\r\n  mediaQuery.addEventListener('change', () => {\r\n    reduceMotion = mediaQuery.matches;\r\n  });\r\n}\r\n\r\n/**\r\n * Convert property name to attribute with hyphens\r\n * @param {string} name\r\n * @returns {string}\r\n */\r\nconst toHyphen = name => name.replace(/([A-Z])/g, '-$1').toLowerCase();\r\n\r\n/**\r\n * @param {object|array<object>} keyframes\r\n * @param {number|object} [options]\r\n * @param {function|null} [startCallback]\r\n * @param {function|null} [endCallback]\r\n * @return {gSVGObject}\r\n * Notice: the original animateTo method is overwriting for this plugin\r\n */\r\nfunction animateTo (keyframes, options = {duration : 200}, startCallback = null, endCallback = null) {\r\n\r\n  const gSVG = this.gSVG;\r\n\r\n  /**\r\n   * Fixed and configure default values for .animateTo() options\r\n   * @param {object} opts\r\n   * @returns {object}\r\n   */\r\n  const normalizeOptions = (opts) => {\r\n    const normalizedConfig = isObject(opts) ? {...opts} : {duration : opts};\r\n    if (reduceMotion) {\r\n      normalizedConfig.duration = 0;\r\n    }\r\n    normalizedConfig.fill = FILL;\r\n    return normalizedConfig;\r\n  }\r\n\r\n  /**\r\n   * Transform and configure default values for .animate() keyframes. Detect unsupported attributes.\r\n   * @param {object|[{}]} originalKeyframes\r\n   * @returns {[{}]}\r\n   */\r\n  const normalizeKeyframes = (originalKeyframes) => {\r\n    originalKeyframes     = isArray(originalKeyframes) ?\r\n      originalKeyframes :\r\n      [originalKeyframes];\r\n    const computedStyle   = window.getComputedStyle(this._el);\r\n    const normalizeFrames = [];\r\n    const alternativeKeys = new Set();\r\n    for (let keyframe of originalKeyframes) {\r\n      const normalized = {...keyframe};\r\n      for (let key in normalized) {\r\n        if (!(key in computedStyle) || exception.includes(key)) {\r\n          alternativeKeys.add(key);\r\n        } else if (key === D) {\r\n          normalized.d = `${ PATH }(\"${ normalized.d }\")`\r\n        } else if (key === TRANSFORM) {\r\n          normalized.transform = transform(normalized.transform)\r\n        }\r\n      }\r\n      normalizeFrames.push(normalized);\r\n    }\r\n    addAlternatives(alternativeKeys, normalizeFrames);\r\n    return normalizeFrames;\r\n  }\r\n\r\n  const alternatives    = []\r\n  /**\r\n   * create SMIL animate as alternative\r\n   * @param {Set} keys\r\n   * @param {[{}]} normalizeFrames\r\n   */\r\n  const addAlternatives = (keys, normalizeFrames) => {\r\n    if (keys.size) {\r\n      const computedFrames = new KeyframeEffect(null, normalizeFrames).getKeyframes();\r\n      const initialTime    = this.closest(SVG) ? this.closest(SVG).getCurrentTime() * 1000 : 0;\r\n      for (let key of keys) {\r\n        const altAnimate = gSVG(ANIMATE)\r\n          .attributeName(key)\r\n          .dur(config.duration + MS)\r\n          .begin((0 | initialTime + (options.delay || 0)) + MS)\r\n          .fill(FREEZE);\r\n        if (normalizeFrames.length === 1) {\r\n          altAnimate.to(normalizeFrames[0][key]);\r\n        } else {\r\n          const keyTimes = [];\r\n          const values   = [];\r\n          for (let n in computedFrames) {\r\n            const frame = computedFrames[n];\r\n            if (key in normalizeFrames[n]) {\r\n              keyTimes.push(frame.computedOffset);\r\n              values.push(normalizeFrames[n][key]);\r\n            }\r\n          }\r\n          if (keyTimes[0] !== 0) {\r\n            keyTimes.unshift(0);\r\n            values.unshift(this[key]() || INHERIT);\r\n          }\r\n          if (keyTimes[keyTimes.length - 1] !== 1) {\r\n            keyTimes.push(1);\r\n            values.push(this[key]() || INHERIT);\r\n          }\r\n          altAnimate.keyTimes(keyTimes.join(';')).values(values.join(';'));\r\n        }\r\n        alternatives.push(altAnimate);\r\n        altAnimate.attachTo(this)\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Normalize a transform property\r\n   * @param {object|string} property\r\n   * @returns {string|*}\r\n   */\r\n  const transform = (property) => {\r\n    if (isString(property)) {\r\n      property = JSON.parse('{' +\r\n                            property\r\n                              .replace(/\\s*\\(\\s*/g, ':[')\r\n                              .replace(/\\s*\\)\\s*/g, '],')\r\n                              .split(/\\s*,\\s*|\\s.*/).join(',')\r\n                              .replace(/(\\w+):/g, '\"$1\":')\r\n                              .replace(/,$/, '')\r\n                            + '}');\r\n    }\r\n    let result = '';\r\n    for (let key in property) {\r\n      if (key === ROTATE) {\r\n        const values = transformValue(property[key]);\r\n        if (values.length > 1) {\r\n          result += `${ TRANSLATE }(${ values[1] }${ PX },${ values[2] }${ PX }) `\r\n        }\r\n        result += `${ key }(${ values[0] }${ transformUnit(key) }) `\r\n        if (values.length > 1) {\r\n          result += `${ TRANSLATE }(-${ values[1] }${ PX },-${ values[2] }${ PX }) `\r\n        }\r\n      } else {\r\n        result += `${ key }(${ transformValue(property[key]).map(v => v + transformUnit(key)).join(',') }) `\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Create a normalized transform value array\r\n   * @param {*} value\r\n   * @returns {[]}\r\n   */\r\n  const transformValue = (value) => (isArray(value) ? value : String(value).split(/\\s+|,/));\r\n\r\n  /**\r\n   * Return the transform value\r\n   * @param {string} type\r\n   * @returns {string}\r\n   */\r\n  const transformUnit = (type) => DEG_TYPES.includes(type) ?\r\n    DEG :\r\n    type === TRANSLATE ? PX : '';\r\n\r\n  /**\r\n   * Convert to valida attribute value\r\n   * @param {string|*} value\r\n   * @returns {string|*}\r\n   */\r\n  const value2attribute = (value) =>\r\n    isString(value) ?\r\n      value.replace(/(deg)|(px)/g, '').trim() :\r\n      value\r\n\r\n  /**\r\n   * Transform d CSS property to valid d attribute format\r\n   * @param {string} d\r\n   * @returns {string}\r\n   */\r\n  const d2attribute = (d) => d\r\n    .replace(/(path\\s*\\(\\s*[\"'])|([\"']\\s*\\)\\s*$)/g, '')\r\n    .trim()\r\n    .replace(/([a-zA-Z])\\s*/g, '$1')\r\n    .replace(/\\s+/g, ',');\r\n\r\n  /**\r\n   * Transform d CSS property to valid d attribute format\r\n   * @param {string} transform\r\n   * @returns {string}\r\n   */\r\n  const transform2attribute = (transform) => {\r\n    const regex = /translate\\((.*)px,(.*)px\\) rotate\\((.*)deg\\) translate\\((.*)px,(.*)px\\)\\s+/;\r\n    const match = regex.exec(transform);\r\n    if (match && Number(match[1]) === Number(match[4]) * -1 && Number(match[2]) === Number(match[5]) * -1) {\r\n      transform = transform.replace(regex, `rotate(${match[3]}, ${match[1]}, ${match[2]})`)\r\n    } else {\r\n      transform = value2attribute(transform);\r\n    }\r\n    return transform;\r\n  }\r\n\r\n\r\n  // Main code\r\n  const config    = normalizeOptions(options);\r\n  const frames    = normalizeKeyframes(keyframes);\r\n  const animation = this._el.animate(frames, config);\r\n\r\n  animation.ready.then(() => isFunction(startCallback) && startCallback.call(this, animation));\r\n\r\n  animation.finished.then(() => {\r\n    const lastAttributes = frames[frames.length - 1];\r\n    for (let attr in lastAttributes) {\r\n      const attrKey = toHyphen(attr);\r\n      if (attrKey.startsWith(\"text-\")) {\r\n        this._el.style[attr] = lastAttributes[attr];\r\n      } else if (attr !== OFFSET && attr in lastAttributes) {\r\n        this._el.setAttribute(\r\n          attrKey,\r\n          attrKey === D ?\r\n            d2attribute(lastAttributes[attr]) :\r\n            attrKey === TRANSFORM ?\r\n              transform2attribute(lastAttributes[attr]) :\r\n              value2attribute(lastAttributes[attr]));\r\n      }\r\n    }\r\n    alternatives.forEach(altAnimate => {\r\n      altAnimate[FINISHED](true);\r\n      const animates = this._el.querySelectorAll(ANIMATE);\r\n      const finished = this._el.querySelectorAll(`${ ANIMATE }[${ FINISHED }]`);\r\n      if (animates.length === finished.length) {\r\n        animates.forEach(a => a.remove())\r\n      }\r\n    });\r\n    isFunction(endCallback) && endCallback.call(this, animation);\r\n  });\r\n\r\n  return this;\r\n}\r\n\r\n\r\nexport function svgPlugin (setup) {\r\n  // Update gSVGObject\r\n  setup.extendInstance({\r\n    animateTo\r\n  });\r\n}", "import {\r\n  ARRAY, OBJECT, NUMBER,\r\n  isArray, isObject, isNumber, isFunction, isUndefined\r\n}                                       from '../helpers/types.js';\r\nimport { createFunction }               from '../helpers/function.create.js';\r\nimport { isValidIdentifier }            from \"../helpers/identifier.js\";\r\nimport { svgPlugin as animateToPlugin } from './animateto.js';\r\n\r\nconst INIT       = Symbol();\r\nconst CLONED     = Symbol();\r\nconst CLONES     = Symbol();\r\nconst TEMPLATE   = Symbol();\r\nconst EVENTS     = Symbol();\r\nconst UNKNOWN    = 'unknown';\r\nconst LABEL      = 'Graphane SVG Template Engine:';\r\nconst directives = [];\r\n\r\n/**\r\n * g-context\r\n * Directive that sets the content of an element to the result of the given expression, especially\r\n * with <tspan></tspan> and <text></text>.\r\n * @example\r\n * <text g-content:=\"value\"></text>\r\n */\r\ndefineDirective({\r\n  name : 'g-content',\r\n  execute (gObject, {expression, data, evalExpression}) {\r\n    gObject.content(evalExpression(expression, data));\r\n  }\r\n});\r\n\r\n/**\r\n * g-if\r\n * Directive that provides an expressive way to show and hide elements.\r\n * @example\r\n * <g g-if=\"value\"></g>\r\n */\r\ndefineDirective({\r\n  name : 'g-if',\r\n  execute (gObject, {expression, data, evalExpression}) {\r\n    gObject.style.visibility(evalExpression(expression, data) ? 'inherit' : 'hidden');\r\n  }\r\n});\r\n\r\n/**\r\n * g-bind: or :\r\n * Directive allowing to set attributes on elements based on the result of the expression. It is\r\n * necessary to indicate the attribute name after the directive or the shorthand.\r\n * @example\r\n * <rect g-bind:x=\"valueX\" :y=\"valueY\"></rect>\r\n */\r\ndefineDirective({\r\n  name     : 'g-bind',\r\n  alias    : ':',\r\n  argument : true,\r\n  execute (gObject, {expression, argument, data, evalExpression}) {\r\n    const context      = {\r\n      ...data,\r\n      $$ : ['d', 'transform'].includes(argument) ?\r\n        gObject['$' + argument] :\r\n        () => gObject[argument]()\r\n    };\r\n    context.$$.dynamic = (value, duration = 200, delay = 0) => {\r\n      gObject.animateTo(\r\n        (isArray(value) ? value : [value]).map(v =>\r\n          isObject(v) && 'offset' in v ?\r\n            {[argument] : v.value, offset : v.offset} :\r\n            {[argument] : v}\r\n        ),\r\n        {duration, delay}\r\n      );\r\n    };\r\n    let value          = evalExpression(expression, context);\r\n    if (argument === 'class') {\r\n      if (isArray(value)) {\r\n        gObject.classList.add(...value.filter(val => !!val));\r\n        return;\r\n      }\r\n      if (isObject(value)) {\r\n        Object.entries(value).forEach(([key, val]) => {\r\n          val ? gObject.classList.add(key) : gObject.classList.remove(key)\r\n        });\r\n        return;\r\n      }\r\n      if (value) {\r\n        gObject.classList.add(value);\r\n      }\r\n      return;\r\n    }\r\n    if (argument === 'style') {\r\n      Object.entries(value).forEach(([key, val]) => gObject.style[key](val));\r\n      return;\r\n    }\r\n    if (!isUndefined(value)) {\r\n      gObject[argument](value);\r\n    }\r\n  }\r\n});\r\n\r\n/**\r\n * g-on: or @\r\n * Directive than allows you to easily run code on dispatched events.\r\n * @example\r\n * <rect g-on:click=\"run\"></rect>\r\n */\r\ndefineDirective({\r\n  name     : 'g-on',\r\n  alias    : '@',\r\n  argument : true,\r\n  execute (gObject, {expression, argument : event, data, evalExpression}) {\r\n    gObject[EVENTS] = gObject[EVENTS] || {};\r\n    const manager   = gObject[EVENTS][event] = gObject[EVENTS][event] || new Map();\r\n    if (manager.has(expression)) {\r\n      gObject.removeEventListener(event, manager.get(expression));\r\n    }\r\n    const handler = function (evt) {\r\n      let fn = evalExpression(expression, data, gObject);\r\n      if (isFunction(fn)) {\r\n        fn.call(gObject, evt);\r\n      }\r\n    };\r\n    gObject.addEventListener(event, handler);\r\n    manager.set(expression, handler);\r\n    if (event === 'init' && !gObject[INIT]) {\r\n      gObject[INIT] = true;\r\n      gObject.dispatchEvent(new Event('init'));\r\n    }\r\n  }\r\n});\r\n\r\n/**\r\n * g-for\r\n * Directive allows you to create elements by iterating through a list. It is only aceptable over\r\n * <defs></defs> element and clones the content for each item into the collection.\r\n * @example\r\n * <defs g-for=\"record of records\">\r\n *   <rect :x=\"record.x\" :y=\"record.y\" :width=\"record.width\" :height=\"record.height\"></rect>\r\n * </defs>\r\n */\r\ndefineDirective({\r\n  name     : 'g-for',\r\n  template : true,\r\n  execute (def, {expression, data}) {\r\n    def[CLONES] = def[CLONES] || [];\r\n    let n       = 0;\r\n    evalForExpression(\r\n      expression,\r\n      data,\r\n      (subData) => {\r\n        if (def[CLONES][n]) {\r\n          process(def[CLONES][n], subData, false);\r\n        } else {\r\n          const g = def.gSVG('g');\r\n          def.children().forEach(child => {\r\n            g.add(child.cloneNode(true));\r\n          });\r\n          process(g, subData);\r\n          def.before(g.el);\r\n          g[CLONED] = true;\r\n          def[CLONES].push(g);\r\n        }\r\n        n++;\r\n      },\r\n      (subData) => {\r\n        while (def[CLONES].length > subData.length) {\r\n          def[CLONES].pop().remove();\r\n        }\r\n      });\r\n  }\r\n});\r\n\r\n\r\n/**\r\n * defineDirective - add a new directive\r\n * @param {Object}   config\r\n * @param {Function} execute\r\n */\r\nfunction defineDirective ({name, alias, argument, template, execute}) {\r\n\r\n  let source  = `^(${\r\n    name\r\n  }${\r\n    argument ? ':' : ''\r\n  }${\r\n    alias ? `|${ alias })` : ')'\r\n  }${\r\n    argument ? `(.*)$` : `$`\r\n  }`\r\n  const check = new RegExp(source, 'i')\r\n\r\n  directives.push({\r\n    name,\r\n    alias,\r\n    argument,\r\n    template,\r\n    execute,\r\n    check\r\n  });\r\n\r\n}\r\n\r\n/**\r\n * findDirective - seeks a defined directive\r\n * @param {string} key\r\n * @returns {Object}\r\n */\r\nfunction findDirective (key) {\r\n  for (const definition of directives) {\r\n    const match = definition.check.exec(key);\r\n    if (match) {\r\n      let argument = match[2];\r\n      return {...definition, argument}\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * getVariables - analyzes a string with destructuring and extract the final variables\r\n * @param {string} expression\r\n * @returns {Array<string>}\r\n */\r\nfunction getVariables (expression) {\r\n  return expression\r\n    .replace(/[{}()[\\]]/g, '')\r\n    .split(',')\r\n    .map(k => k.includes(':') ? k.split(':')[1] : k)\r\n    .map(k => k.trim());\r\n}\r\n\r\n/**\r\n * toIterator - convert a variable into an Array\r\n * @param {any} v\r\n * @returns {{iterator: Array, type: string}}\r\n */\r\nfunction toArray (v) {\r\n  if (v[Symbol.iterator]) {\r\n    return {iterator : [...v], type : ARRAY};\r\n  }\r\n  if (isNumber(v)) {\r\n    return {iterator : Array(v < 0 ? 0 : 0 | v).fill(0).map((v, i) => i), type : NUMBER};\r\n  }\r\n  if (isObject(v)) {\r\n    return {iterator : Object.entries(v).map(m => m.reverse()), type : OBJECT};\r\n  }\r\n  return {iterator : v, type : UNKNOWN};\r\n}\r\n\r\n/**\r\n * evalExpression - evaluate an expression with a data context\r\n * @param {string} code\r\n * @param {object} data\r\n * @param {object} [context=null]\r\n * @returns {*}\r\n */\r\nfunction evalExpression (code, data, context = null) {\r\n  try {\r\n    const keys = Object.keys(data).filter(isValidIdentifier);\r\n    const fn   = createFunction(\r\n      keys,\r\n      `return ( ${ code } ); `\r\n    );\r\n    return fn.apply(context, keys.map(key => data[key]));\r\n  } catch (err) {\r\n    console.warn(LABEL, err.message, '\\n', code);\r\n  }\r\n}\r\n\r\n/**\r\n * evalForExpression - evaluates an expression ` in ` with a data context and calls for each\r\n * occurrence to the callback\r\n * @param {string} code\r\n * @param {object} data\r\n * @param {function} each\r\n * @param {function} final\r\n * @returns {*}\r\n */\r\nfunction evalForExpression (code, data, each, final) {\r\n  const iteratorName = '__$$iterator';\r\n  const callbackName = '__$$callback';\r\n  const finalName    = '__$$final';\r\n  try {\r\n    let [left, right]      = code.split(' of ');\r\n    left                   = left.trim();\r\n    right                  = right.trim();\r\n    const value            = evalExpression(right, data) || [];\r\n    const {iterator, type} = toArray(value);\r\n    if (type === OBJECT && !left.startsWith('[')) {\r\n      left = `[${ left.replace(/(^\\()|(\\)$)/g, '') }]`;\r\n    }\r\n    const variables    = getVariables(left);\r\n    const args         = !left.startsWith('(') ? `(${ left })` : left;\r\n    const dataKeys     = Object.keys(data).filter(isValidIdentifier);\r\n    const codeFunction = `\r\n      ${ iteratorName }.forEach(${ args } => {\r\n        ${ callbackName }({${ dataKeys }${ dataKeys.length ?\r\n      ',' :\r\n      '' }${ variables.join(',') }});\r\n      });\r\n      ${ finalName }(${ iteratorName });\r\n    `;\r\n    const fn           = createFunction([...dataKeys, iteratorName, callbackName, finalName], codeFunction);\r\n    return fn(...dataKeys.map(key => data[key]), iterator, each, final);\r\n  } catch (err) {\r\n    console.warn(LABEL, err);\r\n  }\r\n}\r\n\r\n/**\r\n * process - evaluates a gObject object and renders the content with the directives, creating new\r\n * elements, adding content, filling in attributes, etc.\r\n * @param {Object} el\r\n * @param {Object} data\r\n * @param {boolean} [checkCloned=true]\r\n */\r\nfunction process (el, data, checkCloned = true) {\r\n  if (checkCloned && el[CLONED]) {\r\n    return\r\n  }\r\n  el[TEMPLATE] = el[TEMPLATE] || [];\r\n  const attrs  = el.attributes();\r\n  for (let attr of [...attrs]) {\r\n    const attributeName = attr.name;\r\n    const result        = findDirective(attributeName);\r\n    if (result) {\r\n      el[TEMPLATE].push({...result, expression : attr.value});\r\n      el.removeAttribute(attributeName);\r\n    }\r\n  }\r\n  let template = false;\r\n  for (let directive of el[TEMPLATE]) {\r\n    directive.execute(el, {...directive, data, evalExpression});\r\n    template = directive.template || template;\r\n  }\r\n  if (!template) {\r\n    for (const child of el.children()) {\r\n      process(child, data);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @param {Object|Array} [context]\r\n */\r\nfunction render (context = {}) {\r\n  process(this, context);\r\n  this.dispatchEvent(new Event('render'));\r\n}\r\n\r\n\r\n/**\r\n * Install template plugin\r\n * @param {object} setup\r\n * @example gSVG.install(templateEngine)\r\n */\r\nexport function svgPlugin (setup) {\r\n\r\n  // Dependencies\r\n  setup.install(animateToPlugin);\r\n  // Install\r\n  setup.extendInstance({\r\n    render\r\n  });\r\n  setup.extendSetup({\r\n    extendTemplate : {\r\n      defineDirective,\r\n      obtainDirective (name) {\r\n        return directives.find(directive => directive.name === name);\r\n      }\r\n    }\r\n  })\r\n}"],
  "mappings": "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",
  "names": ["FUNCTION", "UNDEFINED", "OBJECT", "STRING", "ARRAY", "NUMBER", "isObject", "v", "OBJECT", "isString", "STRING", "isFunction", "FUNCTION", "isNumber", "NUMBER", "isUndefined", "UNDEFINED", "isArray", "v", "cache", "AsyncFunction", "createFunction", "args", "code", "async", "key", "cache", "fn", "isValidIdentifier", "identifier", "SVG", "ANIMATE", "FILL", "FREEZE", "PATH", "D", "TRANSFORM", "ROTATE", "TRANSLATE", "OFFSET", "INHERIT", "FINISHED", "DEG_TYPES", "DEG", "PX", "MS", "exception", "reduceMotion", "mediaQuery", "toHyphen", "name", "animateTo", "keyframes", "options", "startCallback", "endCallback", "gSVG", "normalizeOptions", "opts", "normalizedConfig", "isObject", "normalizeKeyframes", "originalKeyframes", "isArray", "computedStyle", "normalizeFrames", "alternativeKeys", "keyframe", "normalized", "key", "transform", "addAlternatives", "alternatives", "keys", "computedFrames", "initialTime", "altAnimate", "config", "keyTimes", "values", "n", "frame", "property", "isString", "result", "transformValue", "transformUnit", "v", "value", "type", "value2attribute", "d2attribute", "d", "transform2attribute", "regex", "match", "frames", "animation", "isFunction", "lastAttributes", "attr", "attrKey", "animates", "finished", "a", "svgPlugin", "setup", "INIT", "CLONED", "CLONES", "TEMPLATE", "EVENTS", "UNKNOWN", "LABEL", "directives", "defineDirective", "gObject", "expression", "data", "evalExpression", "argument", "context", "value", "duration", "delay", "isArray", "v", "isObject", "val", "key", "isUndefined", "event", "manager", "handler", "evt", "fn", "isFunction", "def", "n", "evalForExpression", "subData", "process", "g", "child", "name", "alias", "template", "execute", "source", "check", "findDirective", "definition", "match", "getVariables", "k", "toArray", "ARRAY", "isNumber", "i", "NUMBER", "m", "OBJECT", "code", "keys", "isValidIdentifier", "createFunction", "err", "each", "final", "iteratorName", "callbackName", "finalName", "left", "right", "iterator", "type", "variables", "args", "dataKeys", "codeFunction", "el", "checkCloned", "attrs", "attr", "attributeName", "result", "directive", "render", "svgPlugin", "setup"]
}
