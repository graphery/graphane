{
  "version": 3,
  "sources": ["../../../src/helpers/types.js", "../../../src/plugins/animateto.js"],
  "sourcesContent": ["export const FUNCTION  = 'function';\r\nexport const UNDEFINED = 'undefined';\r\nexport const OBJECT    = 'object';\r\nexport const STRING    = 'string';\r\nexport const ARRAY     = 'array';\r\nexport const NUMBER    = 'number';\r\nexport const BOOLEAN   = 'boolean';\r\nexport const DATE      = 'date';\r\nexport const SYMBOL    = 'symbol';\r\n\r\nexport const EMPTY_STRING = '';\r\nexport const COMA         = ',';\r\nexport const COLON        = ':';\r\nexport const SEMICOLON    = ';';\r\n\r\nexport const isObject    = (v) => typeof v === OBJECT;\r\nexport const isString    = (v) => typeof v === STRING;\r\nexport const isFunction  = (v) => typeof v === FUNCTION;\r\nexport const isNumber    = (v) => typeof v === NUMBER && !isNaN(v);\r\nexport const isUndefined = (v) => typeof v === UNDEFINED;\r\nexport const isSymbol    = (v) => typeof v === SYMBOL;\r\nexport const isBoolean   = (v) => typeof v === BOOLEAN;\r\nexport const isArray     = (v) => Array.isArray(v);\r\nexport const isDate      = (v) => v instanceof Date && !isNaN(v);\r\nexport const isNull      = (v) => v === null;\r\n\r\n/**\r\n * Convert attribute name to camel property name\r\n * @param {string} name\r\n * @return {string}\r\n */\r\nexport const toCamel = name => name.replace(/-([a-z0-9])/g, (x, y) => y.toUpperCase());\r\n\r\n/**\r\n * Converto property name to hyphen attribute name\r\n * @param {string} name\r\n * @return {string}\r\n */\r\nexport const toHyphen = name => {\r\n  name = name.replace(/([A-Z])/g, '-$1').toLowerCase();\r\n  return name.startsWith('-') ? name.slice(1) : name;\r\n};\r\n\r\n\r\n/**\r\n * Convert an object property to an attribute string\r\n * @param {Object} value\r\n * @return {string|undefined}\r\n */\r\nexport function object2attribute (value) {\r\n  if (isObject(value)) {\r\n    let str = '';\r\n    for (let key of Object.keys(value)) {\r\n      str += `${ str ? '; ' : '' }${ key }: ${ value[key] }`;\r\n    }\r\n    return str;\r\n  } else if (isString(value)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Convert an attribute string to an object property\r\n * @param {string} value\r\n * @return {Object|undefined}\r\n */\r\nexport function attribute2object (value) {\r\n  if (isString(value)) {\r\n    try {\r\n      const normalized = value\r\n        .replace(/^\\s*{/, '')\r\n        .replace(/}\\s*$/, '')\r\n        .split(/((?:[^;^,\"']|\"[^\"]*\"|'[^']*')+)/)\r\n        .filter(partial => !['', ';', ','].includes(partial.trim()))\r\n        .map(partial => partial.split(':'))\r\n        .map(partial => `\"${ partial[0].trim() }\":${ str2value(\r\n          partial[1].trim(),\r\n          undefined,\r\n          true\r\n        ) }`)\r\n        .join(',');\r\n      return JSON.parse(`{${ normalized }}`);\r\n    } catch (err) {\r\n      console.error(err);\r\n      return undefined;\r\n    }\r\n  } else if (isObject(value)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Convert an attribute string to an array\r\n * @param {string} value\r\n * @return {Object|undefined}\r\n */\r\nexport function attribute2array (value) {\r\n  if (isString(value)) {\r\n    if (value.trim().startsWith('[')) {\r\n      return (value.match(/\\[(.*?)[^\\]]]/g) || []).map(arr => attribute2array(arr.substring(\r\n        1,\r\n        arr.length - 1\r\n      )));\r\n    } else {\r\n      return value.split(/[,;]/).map(str => str2value(str.trim()));\r\n    }\r\n  } else if (isArray(value)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Convert an attribute string to an array of objects\r\n * @param {string} value\r\n * @return {Object|undefined}\r\n */\r\nexport function attribute2arrayObject (value) {\r\n  if (isString(value)) {\r\n    if (value.trim().startsWith('[')) {\r\n      return (value.match(/\\[(.*?)[^\\]]]/g) || []).map(arr => attribute2object(arr.substring(\r\n        1,\r\n        arr.length - 1\r\n      )));\r\n    } else {\r\n      return [attribute2object(value)];\r\n    }\r\n  } else if (isArray(Array)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n\r\n/**\r\n *\r\n * @param {Object|string} value\r\n * @return {string|undefined}\r\n */\r\nexport function array2attribute (value) {\r\n  if (isArray(value)) {\r\n    let str = JSON.stringify(value);\r\n    return str.substring(1, str.length - 1)\r\n              .replace(/,/g, ', ')\r\n              .replace(/\"/g, '');\r\n  } else if (isString(value)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Convert a string into a value number, boolean or string (with \"\" if quote is true)\r\n * @private\r\n * @param {string} str\r\n * @param {string} [type]\r\n * @param {boolean} [quote=false]\r\n * @return {any}\r\n */\r\nexport function str2value (str, type, quote = false) {\r\n  if (!isString(str)) {\r\n    return str;\r\n  }\r\n  str = removeDoubleQuote(str.trim());\r\n  if (type === ARRAY) {\r\n    return attribute2array(str);\r\n  }\r\n  if (type === OBJECT) {\r\n    return attribute2object(str);\r\n  }\r\n  if (isUndefined(type) || type === NUMBER) {\r\n    if (isUndefined(str) || str === '') {\r\n      return undefined;\r\n    }\r\n    let value = +str;\r\n    if (!Number.isNaN(value) || type === NUMBER) {\r\n      return value;\r\n    }\r\n  }\r\n  if (isUndefined(type) || type === BOOLEAN) {\r\n    if (str === 'true') {\r\n      return true;\r\n    } else if (str === 'false') {\r\n      return false;\r\n    }\r\n    if (type === BOOLEAN) {\r\n      if (str === '0') {\r\n        return false;\r\n      }\r\n      return !!str;\r\n    }\r\n  }\r\n  if (type === DATE) {\r\n    try {\r\n      let value = new Date(str);\r\n      if (!Number.isNaN(value.getTime())) {\r\n        return value;\r\n      }\r\n    } catch (e) {\r\n      void (0);\r\n    }\r\n    return undefined;\r\n  }\r\n  if (isUndefined(type) || type === STRING) {\r\n    return quote ? `\"${ str }\"` : str;\r\n  }\r\n}\r\n\r\nfunction removeDoubleQuote (str) {\r\n  if (\r\n    (str[0] === '\\'' && str[str.length - 1] === '\\'') ||\r\n    (str[0] === '\"' && str[str.length - 1] === '\"')\r\n  ) {\r\n    return str.substring(1, str.length - 1);\r\n  }\r\n  return str;\r\n}\r\n\r\n/**\r\n *\r\n * @param {string} str\r\n * @returns {boolean}\r\n */\r\nexport function isLikeObject (str) {\r\n  return /^\\s*{(.|\\s)*}\\s*$/.test(str);\r\n}\r\n\r\n/**\r\n *\r\n * @param {string} str\r\n * @returns {boolean}\r\n */\r\nexport function isLikeArray (str) {\r\n  return /^\\s*\\[(.|\\s)*]\\s*$/.test(str);\r\n}\r\n\r\n\r\nexport function csvStr2obj (str) {\r\n  let keys = [];\r\n  return str\r\n    .split(/(\\r\\n|\\r|\\n)/)\r\n    .map(r => r.trim())\r\n    .filter(r => r)\r\n    .reduce(\r\n      (result, row, idx) => {\r\n        const obj   = {};\r\n        const parts = row\r\n          .split(/((?:[^;^,\"']|\"[^\"]*\"|'[^']*')+)/)\r\n          .filter(partial => ![EMPTY_STRING, SEMICOLON, COMA].includes(partial.trim()));\r\n        if (idx === 0) {\r\n          keys = [...parts.map(x => str2value(x))];\r\n          return result;\r\n        }\r\n        parts.forEach((part, i) => {\r\n          obj[keys[i]] = str2value(part);\r\n        });\r\n        result.push(obj);\r\n        return result;\r\n      },\r\n      []\r\n    );\r\n}\r\n\r\nexport function jsStr2obj (str) {\r\n  const code = `return (${ str });`\r\n  const ret  = (new Function(code))();\r\n  return typeof ret === 'function' ? ret() : ret;\r\n}\r\n\r\nexport function funcStr2obj (str, $) {\r\n  return (new Function('$', `${ str };let ___$$$ret = {};${\r\n    [...str.matchAll(/\\s*function\\s*(\\w+)/gm)]\r\n      .map(x => `if (typeof ${ x[1] } === 'function') ___$$$ret.${ x[1] } = ${ x[1] };`)\r\n      .join('')\r\n  } return ___$$$ret;`))($);\r\n}", "import { isObject, isString, isFunction, isArray, toCamel } from '../helpers/types.js';\r\n\r\nconst ANIMATE     = 'animate';\r\nconst PATH        = 'path';\r\nconst D           = 'd';\r\nconst TRANSFORM   = 'transform';\r\nconst ROTATE      = 'rotate';\r\nconst TRANSLATE   = 'translate';\r\nconst INHERIT     = 'inherit';\r\nconst FINISHED    = 'finished';\r\nconst TO_DEG      = [ROTATE, 'skewX', 'skewY'];\r\nconst TO_PIXELS   = [TRANSLATE, 'width', 'height', 'x', 'y', 'cx', 'cy', 'r', 'rx', 'ry', 'dx', 'dy'];\r\nconst isException = (tag, key) => ['text', 'tspan'].includes(tag) && ['x', 'y'].includes(key);\r\n\r\n/**\r\n * The reduced-motion flag\r\n * @type {boolean}\r\n */\r\nlet reduceMotion = false;\r\nif (window.matchMedia) {\r\n  const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\r\n  reduceMotion     = mediaQuery.matches;\r\n  mediaQuery.addEventListener('change', () => {\r\n    reduceMotion = mediaQuery.matches;\r\n  });\r\n}\r\n\r\n/**\r\n * Convert property name to attribute with hyphens\r\n * @param {string} name\r\n * @returns {string}\r\n */\r\nconst toHyphen = name => name.replace(/([A-Z])/g, '-$1').toLowerCase();\r\n\r\n/**\r\n * @param {object|array<object>} keyframes\r\n * @param {number|object} [options]\r\n * @param {function|null} [startCallback]\r\n * @param {function|null} [endCallback]\r\n * @return {gSVGObject}\r\n * Notice: the original animateTo method is overwriting for this plugin\r\n */\r\nfunction animateTo (keyframes, options = {duration : 200}, startCallback = null, endCallback = null) {\r\n\r\n  const gSVG = this.gSVG;\r\n\r\n  /**\r\n   * Fixed and configure default values for .animateTo() options\r\n   * @param {object} opts\r\n   * @returns {object}\r\n   */\r\n  const normalizeOptions = (opts) => {\r\n    const normalizedConfig = isObject(opts) ? {...opts} : {duration : opts};\r\n    if (reduceMotion) {\r\n      normalizedConfig.duration = 0;\r\n    }\r\n    normalizedConfig.fill = 'none';\r\n    return normalizedConfig;\r\n  }\r\n\r\n  /**\r\n   * Transform and configure default values for .animate() keyframes. Detect unsupported attributes.\r\n   * @param {object|[{}]} originalKeyframes\r\n   * @returns {[{}]}\r\n   */\r\n  const normalizeKeyframes = (originalKeyframes) => {\r\n    originalKeyframes     = isArray(originalKeyframes) ?\r\n      originalKeyframes :\r\n      [originalKeyframes];\r\n    const computedStyle   = window.getComputedStyle(this._el);\r\n    const normalizeFrames = [];\r\n    const alternativeKeys = new Set();\r\n    for (let keyframe of originalKeyframes) {\r\n      const normalized = {};\r\n      for (let rawKey in keyframe) {\r\n        const key       = toCamel(rawKey);\r\n        normalized[key] = valueUnit(keyframe[rawKey], key);\r\n        if (!(key in computedStyle) || isException(this.tagName(), key)) {\r\n          alternativeKeys.add(key);\r\n        } else if (key === D) {\r\n          normalized.d = `${ PATH }(\"${ normalized.d }\")`\r\n        } else if (key === TRANSFORM) {\r\n          normalized.transform = transform(normalized.transform)\r\n        }\r\n      }\r\n      normalizeFrames.push(normalized);\r\n    }\r\n    addAlternatives(alternativeKeys, normalizeFrames);\r\n    return normalizeFrames;\r\n  }\r\n\r\n  const alternatives    = []\r\n  /**\r\n   * create SMIL animate as alternative\r\n   * @param {Set} keys\r\n   * @param {[{}]} normalizeFrames\r\n   */\r\n  const addAlternatives = (keys, normalizeFrames) => {\r\n    if (keys.size) {\r\n      const computedFrames = new KeyframeEffect(null, normalizeFrames).getKeyframes();\r\n      for (let key of keys) {\r\n        const altAnimate = gSVG(ANIMATE)\r\n          .attributeName(key)\r\n          .dur(config.duration + 'ms')\r\n          .fill('freeze');\r\n        if (normalizeFrames.length === 1) {\r\n          altAnimate.to(normalizeFrames[0][key]);\r\n        } else {\r\n          const keyTimes = [];\r\n          const values   = [];\r\n          for (let n in computedFrames) {\r\n            const frame = computedFrames[n];\r\n            if (key in normalizeFrames[n]) {\r\n              keyTimes.push(frame.computedOffset);\r\n              values.push(normalizeFrames[n][key]);\r\n            }\r\n          }\r\n          if (keyTimes[0] !== 0) {\r\n            keyTimes.unshift(0);\r\n            values.unshift(this[key]() || INHERIT);\r\n          }\r\n          if (keyTimes[keyTimes.length - 1] !== 1) {\r\n            keyTimes.push(1);\r\n            values.push(this[key]() || INHERIT);\r\n          }\r\n          altAnimate.keyTimes(keyTimes.join(';')).values(values.join(';'));\r\n        }\r\n        alternatives.push(altAnimate);\r\n        altAnimate.attachTo(this);\r\n        altAnimate.beginElementAt(config.delay || 0);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Normalize a transform property\r\n   * @param {object|string} property\r\n   * @returns {string|*}\r\n   */\r\n  const transform = (property) => {\r\n    if (isString(property)) {\r\n      property = JSON.parse('{' +\r\n                            property\r\n                              .replace(/\\s*\\(\\s*/g, ':[')\r\n                              .replace(/\\s*\\)\\s*/g, '],')\r\n                              .split(/\\s*,\\s*|\\s.*/).join(',')\r\n                              .replace(/(\\w+):/g, '\"$1\":')\r\n                              .replace(/,$/, '')\r\n                            + '}');\r\n    }\r\n    let result = '';\r\n    for (let key in property) {\r\n      if (key === ROTATE) {\r\n        const values = transformValue(property[key]);\r\n        if (values.length > 1) {\r\n          result += `${ TRANSLATE }(${ valueUnit(values[1], TRANSLATE) },${ valueUnit(values[2], TRANSLATE) }) `\r\n        }\r\n        result += `${ key }(${ valueUnit(values[0], key) }) `\r\n        if (values.length > 1) {\r\n          result += `${ TRANSLATE }(-${ valueUnit(values[1], TRANSLATE) },-${ valueUnit(values[2], TRANSLATE) }) `\r\n        }\r\n      } else {\r\n        result += `${ key }(${ transformValue(property[key]).map(v => valueUnit(v, key)).join(',') }) `\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Create a normalized transform value array\r\n   * @param {*} value\r\n   * @returns {[]}\r\n   */\r\n  const transformValue = (value) => (isArray(value) ? value : String(value).split(/\\s+|,/));\r\n\r\n  /**\r\n   * Return the value with unit\r\n   * @param {number|string} value\r\n   * @param {string} type\r\n   * @returns {string}\r\n   */\r\n  const valueUnit = (value, type) =>\r\n    TO_DEG.includes(type) ? value + 'deg' :\r\n      TO_PIXELS.includes(type) ? value + 'px' :\r\n        value;\r\n\r\n  /**\r\n   * Convert to valida attribute value\r\n   * @param {string|*} value\r\n   * @returns {string|*}\r\n   */\r\n  const value2attribute = (value) =>\r\n    isString(value) ?\r\n      value.replace(/(deg)|(px)/g, '').trim() :\r\n      value\r\n\r\n  /**\r\n   * Transform d CSS property to valid d attribute format\r\n   * @param {string} d\r\n   * @returns {string}\r\n   */\r\n  const d2attribute = (d) => d\r\n    .replace(/(path\\s*\\(\\s*[\"'])|([\"']\\s*\\)\\s*$)/g, '')\r\n    .trim()\r\n    .replace(/([a-zA-Z])\\s*/g, '$1')\r\n    .replace(/\\s+/g, ',');\r\n\r\n  /**\r\n   * Transform d CSS property to valid d attribute format\r\n   * @param {string} transform\r\n   * @returns {string}\r\n   */\r\n  const transform2attribute = (transform) => {\r\n    const regex = /translate\\((.*)px,(.*)px\\) rotate\\((.*)deg\\) translate\\((.*)px,(.*)px\\)\\s+/;\r\n    const match = regex.exec(transform);\r\n    if (match && Number(match[1]) === Number(match[4]) * -1 && Number(match[2]) === Number(match[5]) * -1) {\r\n      transform = transform.replace(regex, `rotate(${ match[3] }, ${ match[1] }, ${ match[2] })`)\r\n    } else {\r\n      transform = value2attribute(transform);\r\n    }\r\n    return transform;\r\n  }\r\n\r\n\r\n  // Main code\r\n  const config    = normalizeOptions(options);\r\n  const frames    = normalizeKeyframes(keyframes);\r\n  const animation = this._el.animate(frames, config);\r\n\r\n  animation.ready.then(() => isFunction(startCallback) && startCallback.call(this, animation));\r\n\r\n  animation.finished.then(() => {\r\n    const lastAttributes = frames[frames.length - 1];\r\n    for (let attr in lastAttributes) {\r\n      const attrKey = toHyphen(attr);\r\n      if (attrKey.startsWith(\"text-\")) {\r\n        this._el.style[attr] = lastAttributes[attr];\r\n      } else if (attr !== 'offset' && attr in lastAttributes) {\r\n        this._el.setAttribute(\r\n          attrKey,\r\n          attrKey === D ?\r\n            d2attribute(lastAttributes[attr]) :\r\n            attrKey === TRANSFORM ?\r\n              transform2attribute(lastAttributes[attr]) :\r\n              value2attribute(lastAttributes[attr]));\r\n      }\r\n    }\r\n    alternatives.forEach(altAnimate => {\r\n      altAnimate[FINISHED](true);\r\n      const animates = this._el.querySelectorAll(ANIMATE);\r\n      const finished = this._el.querySelectorAll(`${ ANIMATE }[${ FINISHED }]`);\r\n      if (animates.length === finished.length) {\r\n        animates.forEach(a => a.remove())\r\n      }\r\n    });\r\n    isFunction(endCallback) && endCallback.call(this, animation);\r\n  });\r\n\r\n  return this;\r\n}\r\n\r\n\r\nexport function svgPlugin (setup) {\r\n  // Update gSVGObject\r\n  setup.extendInstance({\r\n    animateTo\r\n  });\r\n}"],
  "mappings": "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",
  "names": ["FUNCTION", "OBJECT", "STRING", "isObject", "v", "OBJECT", "isString", "STRING", "isFunction", "FUNCTION", "isArray", "v", "toCamel", "name", "x", "y", "ANIMATE", "PATH", "D", "TRANSFORM", "ROTATE", "TRANSLATE", "INHERIT", "FINISHED", "TO_DEG", "TO_PIXELS", "isException", "tag", "key", "reduceMotion", "mediaQuery", "toHyphen", "name", "animateTo", "keyframes", "options", "startCallback", "endCallback", "gSVG", "normalizeOptions", "opts", "normalizedConfig", "isObject", "normalizeKeyframes", "originalKeyframes", "isArray", "computedStyle", "normalizeFrames", "alternativeKeys", "keyframe", "normalized", "rawKey", "toCamel", "valueUnit", "transform", "addAlternatives", "alternatives", "keys", "computedFrames", "altAnimate", "config", "keyTimes", "values", "n", "frame", "property", "isString", "result", "transformValue", "v", "value", "type", "value2attribute", "d2attribute", "d", "transform2attribute", "regex", "match", "frames", "animation", "isFunction", "lastAttributes", "attr", "attrKey", "animates", "finished", "a", "svgPlugin", "setup"]
}
