{
  "version": 3,
  "sources": ["../../src/plugins/observe.resize.js", "../../src/plugins/observe.style.js", "../../src/plugins/keep.aspect.js"],
  "sourcesContent": ["/**\r\n * This callback is displayed as part of the Requester class.\r\n * @callback resizeObserver~callback\r\n * @param {SVGMatrix} currentMatrix\r\n * @param {SVGMatrix} prevMatrix\r\n */\r\n\r\nconst resizeObserverCache = new WeakMap();\r\n\r\n/**\r\n * resizeObserver - call the callback if the SVG is resized\r\n * @param {resizeObserver~callback} [callback]\r\n * @returns {gSVG}\r\n */\r\nfunction resizeObserver (callback = () => void (0)) {\r\n  const self = this;\r\n  const svg  = this.el.tagName.toLowerCase() === 'svg' ? this.el : this.closest('svg').el;\r\n  if (resizeObserverCache.has(svg)) {\r\n    return resizeObserverCache.get(svg).push(callback);\r\n  }\r\n  resizeObserverCache.set(svg, [callback]);\r\n  let prevMatrix = {};\r\n  const check    = () => {\r\n    const currentMatrix = svg.getScreenCTM();\r\n    if (currentMatrix !== null && (\r\n      currentMatrix.a !== prevMatrix.a ||\r\n      currentMatrix.b !== prevMatrix.b ||\r\n      currentMatrix.c !== prevMatrix.c ||\r\n      currentMatrix.d !== prevMatrix.d ||\r\n      currentMatrix.e !== prevMatrix.e ||\r\n      currentMatrix.f !== prevMatrix.f)\r\n    ) {\r\n      const callbacks = resizeObserverCache.get(svg);\r\n      for (let cb of callbacks) {\r\n        cb.call(self, currentMatrix, prevMatrix);\r\n      }\r\n      const event = new CustomEvent(\"resize\", {detail : {currentMatrix, prevMatrix}});\r\n      self.el.dispatchEvent(event);\r\n      prevMatrix = currentMatrix;\r\n    }\r\n    window.requestAnimationFrame(check);\r\n  };\r\n  check();\r\n  return self;\r\n}\r\n\r\n\r\n/**\r\n * resizeObserver plugins installer\r\n * @usage gySVG.install( resizeObserver )\r\n */\r\nexport function svgPlugin (setup) {\r\n  // Update gySVGObject\r\n  setup.extendInstance({\r\n    resizeObserver\r\n  });\r\n}\r\n", "/**\r\n * This callback is displayed as part of the Requester class.\r\n * @callback cssObserver~callback\r\n * @param {SVGElement|gySVGObject} svg\r\n * @param {object} styleValues\r\n */\r\n\r\n/**\r\n * Observe CSS changes\r\n */\r\nconst TIMEOUT     = 100;\r\nlet requestId     = 0;\r\nlet lastExecution = 0;\r\nlet elements      = new Map();\r\nlet run           = false;\r\n\r\n/**\r\n *\r\n * @param {string|Array<string>} properties - List of CSS property to observe\r\n * @param {Function}             callback   - function called when the CSS is changed\r\n * @returns {gSVG}\r\n */\r\nfunction styleObserver (properties, callback = () => void (0)) {\r\n  const element = this.el;\r\n  if (typeof properties === 'string') {\r\n    properties = [properties];\r\n  }\r\n  let observer;\r\n  if (!elements.has(element)) {\r\n    observer = {computedStyles : getComputedStyle(element), styles : {}, keys : []};\r\n    elements.set(element, observer);\r\n  } else {\r\n    observer = elements.get(element);\r\n  }\r\n  for (let property of properties) {\r\n    if (!observer.styles[property]) {\r\n      observer.styles[property] = {\r\n        lastValue : observer.computedStyles[property],\r\n        callbacks : new Set()\r\n      };\r\n      observer.keys.push(property);\r\n    }\r\n    observer.styles[property].callbacks.add(callback);\r\n  }\r\n  observe();\r\n  return this;\r\n}\r\n\r\n/**\r\n * function for observe CSS with requestAnimationFrame\r\n * @param {number} [timestamp]\r\n */\r\nfunction observe (timestamp) {\r\n  if (!run || (timestamp - lastExecution < TIMEOUT)) {\r\n    run       = true;\r\n    requestId = window.requestAnimationFrame(observe);\r\n    return;\r\n  }\r\n  if (!timestamp) {\r\n    return;\r\n  }\r\n  lastExecution = timestamp;\r\n  let callbacks = null;\r\n  for (let [element, observer] of elements.entries()) {\r\n    for (let styleName of observer.keys) {\r\n      const currentStyle = observer.computedStyles.getPropertyValue(styleName);\r\n      const lastStyle    = observer.styles[styleName].lastValue;\r\n      if (currentStyle !== lastStyle) {\r\n        if (!callbacks) {\r\n          callbacks = new Map();\r\n        }\r\n        for (let callback of observer.styles[styleName].callbacks) {\r\n          if (callbacks.has(callback)) {\r\n            callbacks.get(callback)[styleName] = {\r\n              current : currentStyle,\r\n              last    : lastStyle\r\n            };\r\n          } else {\r\n            callbacks.set(callback, {\r\n              [styleName] : {\r\n                current : currentStyle,\r\n                last    : lastStyle\r\n              }\r\n            });\r\n          }\r\n        }\r\n        observer.styles[styleName].lastValue = currentStyle;\r\n      }\r\n    }\r\n    if (callbacks) {\r\n      for (let [callback, values] of callbacks.entries()) {\r\n        callback.call(element, values);\r\n      }\r\n      callbacks = null;\r\n    }\r\n  }\r\n  requestId = window.requestAnimationFrame(observe);\r\n}\r\n\r\n/**\r\n * styleObserver\r\n * @usage gySVG.extension( styleObserver )\r\n * @type {{styleObserver() : gySVGObject}}\r\n */\r\nexport function svgPlugin (setup) {\r\n  // Update gSVGObject\r\n  setup.extendInstance({\r\n    styleObserver\r\n  });\r\n}", "import { svgPlugin as resizeObserver } from './observe.resize.js';\r\nimport { svgPlugin as styleObserver }  from './observe.style.js';\r\n\r\n\r\n/**\r\n * keepAspect - keep the size for text and line elements and the stroke for all elements when the\r\n * SVG is resized or the style is changed.\r\n * @returns {gSVG}\r\n */\r\nfunction keepAspect () {\r\n  const svg = this.closest('svg');\r\n  switch (this.el.tagName.toLowerCase()) {\r\n    case 'text':\r\n      keepTextAspect(svg, this);\r\n      break;\r\n    case 'line':\r\n      keepLineAspect(svg, this);\r\n      break;\r\n    default:\r\n      keepStrokeAspect(svg, this);\r\n  }\r\n  return this;\r\n}\r\n\r\n\r\n/**\r\n *\r\n * @param {gySVGObject} svg\r\n * @param {gySVGObject} shape\r\n */\r\nfunction keepStrokeAspect (svg, shape) {\r\n  let originalCTM     = svg.getScreenCTM() || {a : 1, d : 1};\r\n  let keepStrokeWidth = 0;\r\n  svg.resizeObserver((currentCTM) => {\r\n    const proportion = Math.max(currentCTM.a / originalCTM.a, currentCTM.d / originalCTM.d);\r\n    shape.stroke_width(keepStrokeWidth / proportion);\r\n  });\r\n  svg.styleObserver('stroke-width', (values) => {\r\n    const currentCTM = svg.getScreenCTM();\r\n    keepStrokeWidth  = Number.parseFloat(values['stroke-width'].current);\r\n    const proportion = Math.max(currentCTM.a / originalCTM.a, currentCTM.d / originalCTM.d);\r\n    shape.stroke_width(keepStrokeWidth / proportion);\r\n  })\r\n}\r\n\r\n/**\r\n *\r\n * @param {gySVGObject} svg\r\n * @param {gySVGObject} text\r\n */\r\nfunction keepTextAspect (svg, text) {\r\n  const originalCTM = svg.getScreenCTM() || {a : 1, d : 1};\r\n  text.el._keepX    = text.x();\r\n  text.el._keepY    = text.y();\r\n  svg.resizeObserver((currentCTM) => {\r\n    text.transform(`scale( ${ originalCTM.a / currentCTM.a }, ${ originalCTM.d / currentCTM.d })`);\r\n    text.x(text.el._keepX / (originalCTM.a / currentCTM.a));\r\n    text.y(text.el._keepY / (originalCTM.d / currentCTM.d));\r\n  });\r\n}\r\n\r\n/**\r\n *\r\n * @param {gySVGObject} svg\r\n * @param {gySVGObject} line\r\n */\r\nfunction keepLineAspect (svg, line) {\r\n  const originalCTM = svg.getScreenCTM() || {a : 1, d : 1};\r\n  line.el._keepX1   = line.x1();\r\n  line.el._keepX2   = line.x2();\r\n  line.el._keepY1   = line.y1();\r\n  line.el._keepY2   = line.y2();\r\n  svg.resizeObserver((currentCTM) => {\r\n    line.transform(`scale( ${ originalCTM.a / currentCTM.a }, ${ originalCTM.d / currentCTM.d })`);\r\n    line.x1(line.el._keepX1 / (originalCTM.a / currentCTM.a));\r\n    line.x2(line.el._keepX2 / (originalCTM.a / currentCTM.a));\r\n    line.y1(line.el._keepY1 / (originalCTM.d / currentCTM.d));\r\n    line.y2(line.el._keepY2 / (originalCTM.d / currentCTM.d));\r\n  });\r\n}\r\n\r\nexport function svgPlugin (setup) {\r\n\r\n  // Install dependencies\r\n  setup.install(resizeObserver);\r\n  setup.install(styleObserver);\r\n\r\n  // Update gSVGObject\r\n  setup.extendInstance({\r\n    keepAspect\r\n  });\r\n\r\n}"],
  "mappings": "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",
  "names": ["resizeObserverCache", "resizeObserver", "callback", "self", "svg", "prevMatrix", "check", "currentMatrix", "callbacks", "cb", "event", "svgPlugin", "setup", "requestId", "lastExecution", "elements", "run", "styleObserver", "properties", "callback", "element", "observer", "property", "observe", "timestamp", "callbacks", "styleName", "currentStyle", "lastStyle", "values", "svgPlugin", "setup", "keepAspect", "svg", "keepTextAspect", "keepLineAspect", "keepStrokeAspect", "shape", "originalCTM", "keepStrokeWidth", "currentCTM", "proportion", "values", "text", "line", "svgPlugin", "setup"]
}
