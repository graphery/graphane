{
  "version": 3,
  "sources": ["../../src/helpers/types.js", "../../src/plugins/animateto.js"],
  "sourcesContent": ["export const FUNCTION  = 'function';\r\nexport const UNDEFINED = 'undefined';\r\nexport const OBJECT    = 'object';\r\nexport const STRING    = 'string';\r\nexport const ARRAY     = 'array';\r\nexport const NUMBER    = 'number';\r\nexport const BOOLEAN   = 'boolean';\r\nexport const DATE      = 'date';\r\nexport const SYMBOL    = 'symbol';\r\n\r\nexport const EMPTY_STRING = '';\r\nexport const COMA         = ',';\r\nexport const COLON        = ':';\r\nexport const SEMICOLON    = ';';\r\n\r\nexport const isObject    = (v) => typeof v === OBJECT;\r\nexport const isString    = (v) => typeof v === STRING;\r\nexport const isFunction  = (v) => typeof v === FUNCTION;\r\nexport const isNumber    = (v) => typeof v === NUMBER && !isNaN(v);\r\nexport const isUndefined = (v) => typeof v === UNDEFINED;\r\nexport const isSymbol    = (v) => typeof v === SYMBOL;\r\nexport const isBoolean   = (v) => typeof v === BOOLEAN;\r\nexport const isArray     = (v) => Array.isArray(v);\r\nexport const isDate      = (v) => v instanceof Date && !isNaN(v);\r\nexport const isNull      = (v) => v === null;\r\n\r\n/**\r\n * Convert attribute name to camel property name\r\n * @param {string} name\r\n * @return {string}\r\n */\r\nexport const toCamel = name => name.replace(/-([a-z0-9])/g, (x, y) => y.toUpperCase());\r\n\r\n/**\r\n * Converto property name to hyphen attribute name\r\n * @param {string} name\r\n * @return {string}\r\n */\r\nexport const toHyphen = name => {\r\n  name = name.replace(/([A-Z])/g, '-$1').toLowerCase();\r\n  return name[0] === '-' ? name.slice(1) : name;\r\n};\r\n\r\n\r\n/**\r\n * Convert an object property to an attribute string\r\n * @param {Object} value\r\n * @return {string|undefined}\r\n */\r\nexport function object2attribute (value) {\r\n  if (isObject(value)) {\r\n    let str = '';\r\n    for (let key of Object.keys(value)) {\r\n      str += `${ str ? '; ' : '' }${ key }: ${ value[key] }`;\r\n    }\r\n    return str;\r\n  } else if (isString(value)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Convert an attribute string to an object property\r\n * @param {string} value\r\n * @return {Object|undefined}\r\n */\r\nexport function attribute2object (value) {\r\n  if (isString(value)) {\r\n    try {\r\n      const normalized = value\r\n        .replace(/^\\s*{/,'')\r\n        .replace(/}\\s*$/,'')\r\n        .split(/((?:[^;^,\"']|\"[^\"]*\"|'[^']*')+)/)\r\n        .filter(partial => !['', ';', ','].includes(partial.trim()))\r\n        .map(partial => partial.split(':'))\r\n        .map(partial => `\"${ partial[0].trim() }\":${ str2value(\r\n          partial[1].trim(),\r\n          undefined,\r\n          true\r\n        ) }`)\r\n        .join(',');\r\n      return JSON.parse(`{${ normalized }}`);\r\n    } catch (err) {\r\n      console.error(err);\r\n      return undefined;\r\n    }\r\n  } else if (isObject(value)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Convert an attribute string to an array\r\n * @param {string} value\r\n * @return {Object|undefined}\r\n */\r\nexport function attribute2array (value) {\r\n  if (isString(value)) {\r\n    if (value.trim()[0] === '[') {\r\n      return (value.match(/\\[(.*?)[^\\]]]/g) || []).map(arr => attribute2array(arr.substring(\r\n        1,\r\n        arr.length - 1\r\n      )));\r\n    } else {\r\n      return value.split(/[,;]/).map(str => str2value(str.trim()));\r\n    }\r\n  } else if (isArray(value)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Convert an attribute string to an array of objects\r\n * @param {string} value\r\n * @return {Object|undefined}\r\n */\r\nexport function attribute2arrayObject (value) {\r\n  if (isString(value)) {\r\n    if (value.trim()[0] === '[') {\r\n      return (value.match(/\\[(.*?)[^\\]]]/g) || []).map(arr => attribute2object(arr.substring(\r\n        1,\r\n        arr.length - 1\r\n      )));\r\n    } else {\r\n      return [attribute2object(value)];\r\n    }\r\n  } else if (isArray(Array)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n\r\n/**\r\n *\r\n * @param {Object} value\r\n * @return {string|undefined}\r\n */\r\nexport function array2attribute (value) {\r\n  if (isArray(value)) {\r\n    let str = JSON.stringify(value);\r\n    return str.substr(1, str.length - 2)\r\n              .replace(/,/g, ', ')\r\n              .replace(/\"/g, '');\r\n  } else if (isString(value)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Convert a string into a value number, boolean or string (with \"\" if quote is true)\r\n * @private\r\n * @param {string} str\r\n * @param {string} [type]\r\n * @param {boolean} [quote=false]\r\n * @return {any}\r\n */\r\nexport function str2value (str, type, quote = false) {\r\n  if (!isString(str)) {\r\n    return str;\r\n  }\r\n  str = removeDoubleQuote(str.trim());\r\n  if (type === ARRAY) {\r\n    return attribute2array(str);\r\n  }\r\n  if (type === OBJECT) {\r\n    return attribute2object(str);\r\n  }\r\n  if (isUndefined(type) || type === NUMBER) {\r\n    if (isUndefined(str) || str === '') {\r\n      return undefined;\r\n    }\r\n    let value = +str;\r\n    if (!Number.isNaN(value) || type === NUMBER) {\r\n      return value;\r\n    }\r\n  }\r\n  if (isUndefined(type) || type === BOOLEAN) {\r\n    if (str === 'true') {\r\n      return true;\r\n    } else if (str === 'false') {\r\n      return false;\r\n    }\r\n    if (type === BOOLEAN) {\r\n      if (str === '0') {\r\n        return false;\r\n      }\r\n      return !!str;\r\n    }\r\n  }\r\n  if (type === DATE) {\r\n    try {\r\n      let value = new Date(str);\r\n      if (!Number.isNaN(value.getTime())) {\r\n        return value;\r\n      }\r\n    } catch (e) {\r\n      void (0);\r\n    }\r\n    return undefined;\r\n  }\r\n  if (isUndefined(type) || type === STRING) {\r\n    return quote ? `\"${ str }\"` : str;\r\n  }\r\n}\r\n\r\nfunction removeDoubleQuote (str) {\r\n  if (\r\n    (str[0] === '\\'' && str[str.length - 1] === '\\'') ||\r\n    (str[0] === '\"' && str[str.length - 1] === '\"')\r\n  ) {\r\n    return str.substring(1, str.length - 1);\r\n  }\r\n  return str;\r\n}\r\n\r\n/**\r\n *\r\n * @param {string} str\r\n * @returns {boolean}\r\n */\r\nexport function isLikeObject(str) {\r\n  return /^\\s*{(.|\\s)*}\\s*$/.test(str);\r\n}\r\n\r\n/**\r\n *\r\n * @param {string} str\r\n * @returns {boolean}\r\n */\r\nexport function isLikeArray(str) {\r\n  return /^\\s*\\[(.|\\s)*]\\s*$/.test(str);\r\n}\r\n\r\n\r\nexport function csvStr2obj (str) {\r\n  let keys = [];\r\n  return str\r\n    .split(/(\\r\\n|\\r|\\n)/)\r\n    .map(r => r.trim())\r\n    .filter(r => r)\r\n    .reduce(\r\n      (result, row, idx) => {\r\n        const obj   = {};\r\n        const parts = row\r\n          .split(/((?:[^;^,\"']|\"[^\"]*\"|'[^']*')+)/)\r\n          .filter(partial => ![EMPTY_STRING, SEMICOLON, COMA].includes(partial.trim()));\r\n        if (idx === 0) {\r\n          keys = [...parts.map(p => JSON.parse(p))];\r\n          return result;\r\n        }\r\n        parts.forEach((part, i) => {\r\n          obj[keys[i]] = JSON.parse(part);\r\n        });\r\n        result.push(obj);\r\n        return result;\r\n      },\r\n      []\r\n    );\r\n}\r\n\r\nexport function jsStr2obj (str) {\r\n  const code = `return (${ str });`\r\n  const ret  = (new Function(code))();\r\n  return typeof ret === 'function' ? ret() : ret;\r\n}\r\n\r\nexport function funcStr2obj (str, $) {\r\n  return (new Function('$', `${ str };let ___$$$ret = {};${\r\n    [...str.matchAll(/\\s*function\\s*(\\w+)/gm)]\r\n      .map(x => `if (typeof ${ x[1] } === 'function') ___$$$ret.${ x[1] } = ${ x[1] };`)\r\n      .join('')\r\n  } return ___$$$ret;`))($);\r\n}", "import { isObject, isString, isFunction, isArray } from '../helpers/types.js';\r\n\r\nconst SVG       = 'SVG';\r\nconst ANIMATE   = 'animate';\r\nconst FILL      = 'none';\r\nconst FREEZE    = 'freeze';\r\nconst PATH      = 'path';\r\nconst D         = 'd';\r\nconst TRANSFORM = 'transform';\r\nconst ROTATE    = 'rotate';\r\nconst TRANSLATE = 'translate';\r\nconst OFFSET    = 'offset';\r\nconst INHERIT   = 'inherit';\r\nconst FINISHED  = 'finished';\r\nconst DEG_TYPES = [ROTATE, 'skewX', 'skewY'];\r\nconst DEG       = 'deg';\r\nconst PX        = 'px';\r\nconst MS        = 'ms';\r\nconst exception = ['width', 'height'];\r\n\r\n/**\r\n * The reduced-motion flag\r\n * @type {boolean}\r\n */\r\nlet reduceMotion = false;\r\nif (window.matchMedia) {\r\n  const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\r\n  reduceMotion     = mediaQuery.matches;\r\n  mediaQuery.addEventListener('change', () => {\r\n    reduceMotion = mediaQuery.matches;\r\n  });\r\n}\r\n\r\n/**\r\n * Convert property name to attribute with hyphens\r\n * @param {string} name\r\n * @returns {string}\r\n */\r\nconst toHyphen = name => name.replace(/([A-Z])/g, '-$1').toLowerCase();\r\n\r\n/**\r\n * @param {object|array<object>} keyframes\r\n * @param {number|object} [options]\r\n * @param {function|null} [startCallback]\r\n * @param {function|null} [endCallback]\r\n * @return {gSVGObject}\r\n * Notice: the original animateTo method is overwriting for this plugin\r\n */\r\nfunction animateTo (keyframes, options = {duration : 200}, startCallback = null, endCallback = null) {\r\n\r\n  const gSVG = this.gSVG;\r\n\r\n  /**\r\n   * Fixed and configure default values for .animateTo() options\r\n   * @param {object} opts\r\n   * @returns {object}\r\n   */\r\n  const normalizeOptions = (opts) => {\r\n    const normalizedConfig = isObject(opts) ? Object.assign({}, opts) : {duration : opts};\r\n    if (reduceMotion) {\r\n      normalizedConfig.duration = 0;\r\n    }\r\n    normalizedConfig.fill = FILL;\r\n    return normalizedConfig;\r\n  }\r\n\r\n  /**\r\n   * Transform and configure default values for .animate() keyframes. Detect unsupported attributes.\r\n   * @param {object|[{}]} originalKeyframes\r\n   * @returns {[{}]}\r\n   */\r\n  const normalizeKeyframes = (originalKeyframes) => {\r\n    originalKeyframes     = isArray(originalKeyframes) ?\r\n      originalKeyframes :\r\n      [originalKeyframes];\r\n    const computedStyle   = window.getComputedStyle(this._el);\r\n    const normalizeFrames = [];\r\n    const alternativeKeys = new Set();\r\n    for (let keyframe of originalKeyframes) {\r\n      const normalized = Object.assign({}, keyframe);\r\n      for (let key in normalized) {\r\n        if (!(key in computedStyle) || exception.includes(key)) {\r\n          alternativeKeys.add(key);\r\n        } else if (key === D) {\r\n          normalized.d = `${ PATH }(\"${ normalized.d }\")`\r\n        } else if (key === TRANSFORM) {\r\n          normalized.transform = transform(normalized.transform)\r\n        }\r\n      }\r\n      normalizeFrames.push(normalized);\r\n    }\r\n    addAlternatives(alternativeKeys, normalizeFrames);\r\n    return normalizeFrames;\r\n  }\r\n\r\n  const alternatives    = []\r\n  /**\r\n   * create SMIL animate as alternative\r\n   * @param {Set} keys\r\n   * @param {[{}]} normalizeFrames\r\n   */\r\n  const addAlternatives = (keys, normalizeFrames) => {\r\n    if (keys.size) {\r\n      const computedFrames = new KeyframeEffect(null, normalizeFrames).getKeyframes();\r\n      const initialTime    = this.closest(SVG) ? this.closest(SVG).getCurrentTime() * 1000 : 0;\r\n      for (let key of keys) {\r\n        const altAnimate = gSVG(ANIMATE)\r\n          .attributeName(key)\r\n          .dur(config.duration + MS)\r\n          .begin((0 | initialTime + (options.delay || 0)) + MS)\r\n          .fill(FREEZE);\r\n        if (normalizeFrames.length === 1) {\r\n          altAnimate.to(normalizeFrames[0][key]);\r\n        } else {\r\n          const keyTimes = [];\r\n          const values   = [];\r\n          for (let n in computedFrames) {\r\n            const frame = computedFrames[n];\r\n            if (key in normalizeFrames[n]) {\r\n              keyTimes.push(frame.computedOffset);\r\n              values.push(normalizeFrames[n][key]);\r\n            }\r\n          }\r\n          if (keyTimes[0] !== 0) {\r\n            keyTimes.unshift(0);\r\n            values.unshift(this[key]() || INHERIT);\r\n          }\r\n          if (keyTimes[keyTimes.length - 1] !== 1) {\r\n            keyTimes.push(1);\r\n            values.push(this[key]() || INHERIT);\r\n          }\r\n          altAnimate.keyTimes(keyTimes.join(';')).values(values.join(';'));\r\n        }\r\n        alternatives.push(altAnimate);\r\n        altAnimate.attachTo(this)\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Normalize a transform property\r\n   * @param {object|string} property\r\n   * @returns {string|*}\r\n   */\r\n  const transform = (property) => {\r\n    if (isString(property)) {\r\n      property = JSON.parse('{' +\r\n                            property\r\n                              .replace(/\\s*\\(\\s*/g, ':[')\r\n                              .replace(/\\s*\\)\\s*/g, '],')\r\n                              .split(/\\s*,\\s*|\\s.*/).join(',')\r\n                              .replace(/(\\w+):/g, '\"$1\":')\r\n                              .replace(/,$/, '')\r\n                            + '}');\r\n    }\r\n    let result = '';\r\n    for (let key in property) {\r\n      if (key === ROTATE) {\r\n        const values = transformValue(property[key]);\r\n        if (values.length > 1) {\r\n          result += `${ TRANSLATE }(${ values[1] }${ PX },${ values[2] }${ PX }) `\r\n        }\r\n        result += `${ key }(${ values[0] }${ transformUnit(key) }) `\r\n        if (values.length > 1) {\r\n          result += `${ TRANSLATE }(-${ values[1] }${ PX },-${ values[2] }${ PX }) `\r\n        }\r\n      } else {\r\n        result += `${ key }(${ transformValue(property[key]).map(v => v + transformUnit(key)).join(',') }) `\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Create a normalized transform value array\r\n   * @param {*} value\r\n   * @returns {[]}\r\n   */\r\n  const transformValue = (value) => (isArray(value) ? value : String(value).split(/\\s+|,/));\r\n\r\n  /**\r\n   * Return the transform value\r\n   * @param {string} type\r\n   * @returns {string}\r\n   */\r\n  const transformUnit = (type) => DEG_TYPES.includes(type) ?\r\n    DEG :\r\n    type === TRANSLATE ? PX : '';\r\n\r\n  /**\r\n   * Convert to valida attribute value\r\n   * @param {string|*} value\r\n   * @returns {string|*}\r\n   */\r\n  const value2attribute = (value) =>\r\n    isString(value) ?\r\n      value.replace(/(deg)|(px)/g, '').trim() :\r\n      value\r\n\r\n  /**\r\n   * Transform d CSS property to valid d attribute format\r\n   * @param {string} d\r\n   * @returns {string}\r\n   */\r\n  const d2attribute = (d) => d\r\n    .replace(/(path\\s*\\(\\s*[\"'])|([\"']\\s*\\)\\s*$)/g, '')\r\n    .trim()\r\n    .replace(/([a-zA-Z])\\s*/g, '$1')\r\n    .replace(/\\s+/g, ',');\r\n\r\n  // Main code\r\n  const config    = normalizeOptions(options);\r\n  const frames    = normalizeKeyframes(keyframes);\r\n  const animation = this._el.animate(frames, config);\r\n\r\n  animation.ready.then(() => isFunction(startCallback) && startCallback.call(this, animation));\r\n\r\n  animation.finished.then(() => {\r\n    const lastAttributes = frames[frames.length - 1];\r\n    for (let attr in lastAttributes) {\r\n      const attrKey = toHyphen(attr);\r\n      if (/^text-/.test(attrKey)) {\r\n        this._el.style[attr] = lastAttributes[attr];\r\n      } else if (attr !== OFFSET && attr in lastAttributes) {\r\n        this._el.setAttribute(\r\n          attrKey,\r\n          attrKey === D ?\r\n            d2attribute(lastAttributes[attr]) :\r\n            value2attribute(lastAttributes[attr]));\r\n      }\r\n    }\r\n    alternatives.forEach(altAnimate => {\r\n      altAnimate[FINISHED](true);\r\n      const animates = this._el.querySelectorAll(ANIMATE);\r\n      const finished = this._el.querySelectorAll(`${ ANIMATE }[${ FINISHED }]`);\r\n      if (animates.length === finished.length) {\r\n        animates.forEach(a => a.remove())\r\n      }\r\n    });\r\n    isFunction(endCallback) && endCallback.call(this, animation);\r\n  });\r\n\r\n  return this;\r\n}\r\n\r\n\r\nexport function svgPlugin (setup) {\r\n  // Update gSVGObject\r\n  setup.extendInstance({\r\n    animateTo\r\n  });\r\n}"],
  "mappings": "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",
  "names": ["FUNCTION", "OBJECT", "STRING", "isObject", "v", "OBJECT", "isString", "STRING", "isFunction", "FUNCTION", "isArray", "v", "SVG", "ANIMATE", "FILL", "FREEZE", "PATH", "D", "TRANSFORM", "ROTATE", "TRANSLATE", "OFFSET", "INHERIT", "FINISHED", "DEG_TYPES", "DEG", "PX", "MS", "exception", "reduceMotion", "mediaQuery", "toHyphen", "name", "animateTo", "keyframes", "options", "startCallback", "endCallback", "gSVG", "normalizeOptions", "opts", "normalizedConfig", "isObject", "normalizeKeyframes", "originalKeyframes", "isArray", "computedStyle", "normalizeFrames", "alternativeKeys", "keyframe", "normalized", "key", "transform", "addAlternatives", "alternatives", "keys", "computedFrames", "initialTime", "altAnimate", "config", "keyTimes", "values", "n", "frame", "property", "isString", "result", "transformValue", "transformUnit", "v", "value", "type", "value2attribute", "d2attribute", "d", "frames", "animation", "isFunction", "lastAttributes", "attr", "attrKey", "animates", "finished", "a", "svgPlugin", "setup"]
}
