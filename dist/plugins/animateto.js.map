{
  "version": 3,
  "sources": ["../../src/helpers/types.js", "../../src/plugins/animateto.js"],
  "sourcesContent": ["export const FUNCTION  = 'function';\r\nexport const UNDEFINED = 'undefined';\r\nexport const OBJECT    = 'object';\r\nexport const STRING    = 'string';\r\nexport const ARRAY     = 'array';\r\nexport const NUMBER    = 'number';\r\nexport const BOOLEAN   = 'boolean';\r\nexport const DATE      = 'date';\r\nexport const SYMBOL    = 'symbol';\r\n\r\nexport const EMPTY_STRING = '';\r\nexport const COMA         = ',';\r\nexport const COLON        = ':';\r\nexport const SEMICOLON    = ';';\r\n\r\nexport const isObject    = (v) => typeof v === OBJECT;\r\nexport const isString    = (v) => typeof v === STRING;\r\nexport const isFunction  = (v) => typeof v === FUNCTION;\r\nexport const isNumber    = (v) => typeof v === NUMBER && !isNaN(v);\r\nexport const isUndefined = (v) => typeof v === UNDEFINED;\r\nexport const isSymbol    = (v) => typeof v === SYMBOL;\r\nexport const isBoolean   = (v) => typeof v === BOOLEAN;\r\nexport const isArray     = (v) => Array.isArray(v);\r\nexport const isDate      = (v) => v instanceof Date && !isNaN(v);\r\nexport const isNull      = (v) => v === null;\r\n\r\n/**\r\n * Convert attribute name to camel property name\r\n * @param {string} name\r\n * @return {string}\r\n */\r\nexport const toCamel = name => name.replace(/-([a-z0-9])/g, (x, y) => y.toUpperCase());\r\n\r\n/**\r\n * Converto property name to hyphen attribute name\r\n * @param {string} name\r\n * @return {string}\r\n */\r\nexport const toHyphen = name => {\r\n  name = name.replace(/([A-Z])/g, '-$1').toLowerCase();\r\n  return name.startsWith('-') ? name.slice(1) : name;\r\n};\r\n\r\n\r\n/**\r\n * Convert an object property to an attribute string\r\n * @param {Object} value\r\n * @return {string|undefined}\r\n */\r\nexport function object2attribute (value) {\r\n  if (isObject(value)) {\r\n    let str = '';\r\n    for (let key of Object.keys(value)) {\r\n      str += `${ str ? '; ' : '' }${ key }: ${ value[key] }`;\r\n    }\r\n    return str;\r\n  } else if (isString(value)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Convert an attribute string to an object property\r\n * @param {string} value\r\n * @return {Object|undefined}\r\n */\r\nexport function attribute2object (value) {\r\n  if (isString(value)) {\r\n    try {\r\n      const normalized = value\r\n        .replace(/^\\s*{/, '')\r\n        .replace(/}\\s*$/, '')\r\n        .split(/((?:[^;^,\"']|\"[^\"]*\"|'[^']*')+)/)\r\n        .filter(partial => !['', ';', ','].includes(partial.trim()))\r\n        .map(partial => partial.split(':'))\r\n        .map(partial => `\"${ partial[0].trim() }\":${ str2value(\r\n          partial[1].trim(),\r\n          undefined,\r\n          true\r\n        ) }`)\r\n        .join(',');\r\n      return JSON.parse(`{${ normalized }}`);\r\n    } catch (err) {\r\n      console.error(err);\r\n      return undefined;\r\n    }\r\n  } else if (isObject(value)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Convert an attribute string to an array\r\n * @param {string} value\r\n * @return {Object|undefined}\r\n */\r\nexport function attribute2array (value) {\r\n  if (isString(value)) {\r\n    if (value.trim().startsWith('[')) {\r\n      return (value.match(/\\[(.*?)[^\\]]]/g) || []).map(arr => attribute2array(arr.substring(\r\n        1,\r\n        arr.length - 1\r\n      )));\r\n    } else {\r\n      return value.split(/[,;]/).map(str => str2value(str.trim()));\r\n    }\r\n  } else if (isArray(value)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Convert an attribute string to an array of objects\r\n * @param {string} value\r\n * @return {Object|undefined}\r\n */\r\nexport function attribute2arrayObject (value) {\r\n  if (isString(value)) {\r\n    if (value.trim().startsWith('[')) {\r\n      return (value.match(/\\[(.*?)[^\\]]]/g) || []).map(arr => attribute2object(arr.substring(\r\n        1,\r\n        arr.length - 1\r\n      )));\r\n    } else {\r\n      return [attribute2object(value)];\r\n    }\r\n  } else if (isArray(Array)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n\r\n/**\r\n *\r\n * @param {Object|string} value\r\n * @return {string|undefined}\r\n */\r\nexport function array2attribute (value) {\r\n  if (isArray(value)) {\r\n    let str = JSON.stringify(value);\r\n    return str.substring(1, str.length - 1)\r\n              .replace(/,/g, ', ')\r\n              .replace(/\"/g, '');\r\n  } else if (isString(value)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Convert a string into a value number, boolean or string (with \"\" if quote is true)\r\n * @private\r\n * @param {string} str\r\n * @param {string} [type]\r\n * @param {boolean} [quote=false]\r\n * @return {any}\r\n */\r\nexport function str2value (str, type, quote = false) {\r\n  if (!isString(str)) {\r\n    return str;\r\n  }\r\n  str = removeDoubleQuote(str.trim());\r\n  if (type === ARRAY) {\r\n    return attribute2array(str);\r\n  }\r\n  if (type === OBJECT) {\r\n    return attribute2object(str);\r\n  }\r\n  if (isUndefined(type) || type === NUMBER) {\r\n    if (isUndefined(str) || str === '') {\r\n      return undefined;\r\n    }\r\n    let value = +str;\r\n    if (!Number.isNaN(value) || type === NUMBER) {\r\n      return value;\r\n    }\r\n  }\r\n  if (isUndefined(type) || type === BOOLEAN) {\r\n    if (str === 'true') {\r\n      return true;\r\n    } else if (str === 'false') {\r\n      return false;\r\n    }\r\n    if (type === BOOLEAN) {\r\n      if (str === '0') {\r\n        return false;\r\n      }\r\n      return !!str;\r\n    }\r\n  }\r\n  if (type === DATE) {\r\n    try {\r\n      let value = new Date(str);\r\n      if (!Number.isNaN(value.getTime())) {\r\n        return value;\r\n      }\r\n    } catch (e) {\r\n      void (0);\r\n    }\r\n    return undefined;\r\n  }\r\n  if (isUndefined(type) || type === STRING) {\r\n    return quote ? `\"${ str }\"` : str;\r\n  }\r\n}\r\n\r\nfunction removeDoubleQuote (str) {\r\n  if (\r\n    (str[0] === '\\'' && str[str.length - 1] === '\\'') ||\r\n    (str[0] === '\"' && str[str.length - 1] === '\"')\r\n  ) {\r\n    return str.substring(1, str.length - 1);\r\n  }\r\n  return str;\r\n}\r\n\r\n/**\r\n *\r\n * @param {string} str\r\n * @returns {boolean}\r\n */\r\nexport function isLikeObject (str) {\r\n  return /^\\s*{(.|\\s)*}\\s*$/.test(str);\r\n}\r\n\r\n/**\r\n *\r\n * @param {string} str\r\n * @returns {boolean}\r\n */\r\nexport function isLikeArray (str) {\r\n  return /^\\s*\\[(.|\\s)*]\\s*$/.test(str);\r\n}\r\n\r\n\r\nexport function csvStr2obj (str) {\r\n  let keys = [];\r\n  return str\r\n    .split(/(\\r\\n|\\r|\\n)/)\r\n    .map(r => r.trim())\r\n    .filter(r => r)\r\n    .reduce(\r\n      (result, row, idx) => {\r\n        const obj   = {};\r\n        const parts = row\r\n          .split(/((?:[^;^,\"']|\"[^\"]*\"|'[^']*')+)/)\r\n          .filter(partial => ![EMPTY_STRING, SEMICOLON, COMA].includes(partial.trim()));\r\n        if (idx === 0) {\r\n          keys = [...parts.map(x => str2value(x))];\r\n          return result;\r\n        }\r\n        parts.forEach((part, i) => {\r\n          obj[keys[i]] = str2value(part);\r\n        });\r\n        result.push(obj);\r\n        return result;\r\n      },\r\n      []\r\n    );\r\n}\r\n\r\nexport function jsStr2obj (str) {\r\n  const code = `return (${ str });`\r\n  const ret  = (new Function(code))();\r\n  return typeof ret === 'function' ? ret() : ret;\r\n}\r\n\r\nexport function funcStr2obj (str, $) {\r\n  return (new Function('$', `${ str };let ___$$$ret = {};${\r\n    [...str.matchAll(/\\s*function\\s*(\\w+)/gm)]\r\n      .map(x => `if (typeof ${ x[1] } === 'function') ___$$$ret.${ x[1] } = ${ x[1] };`)\r\n      .join('')\r\n  } return ___$$$ret;`))($);\r\n}", "import { isObject, isString, isFunction, isArray, toCamel } from '../helpers/types.js';\r\n\r\nconst SVG       = 'SVG';\r\nconst ANIMATE   = 'animate';\r\nconst FILL      = 'none';\r\nconst FREEZE    = 'freeze';\r\nconst PATH      = 'path';\r\nconst D         = 'd';\r\nconst TRANSFORM = 'transform';\r\nconst ROTATE    = 'rotate';\r\nconst TRANSLATE = 'translate';\r\nconst OFFSET    = 'offset';\r\nconst INHERIT   = 'inherit';\r\nconst FINISHED  = 'finished';\r\nconst DEG_TYPES = [ROTATE, 'skewX', 'skewY'];\r\nconst DEG       = 'deg';\r\nconst PX        = 'px';\r\nconst MS        = 'ms';\r\nconst TO_PIXELS = ['width', 'height', 'x' , 'y', 'cx', 'cy', 'r', 'rx', 'ry'];\r\n\r\n/**\r\n * The reduced-motion flag\r\n * @type {boolean}\r\n */\r\nlet reduceMotion = false;\r\nif (window.matchMedia) {\r\n  const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\r\n  reduceMotion     = mediaQuery.matches;\r\n  mediaQuery.addEventListener('change', () => {\r\n    reduceMotion = mediaQuery.matches;\r\n  });\r\n}\r\n\r\n/**\r\n * Convert property name to attribute with hyphens\r\n * @param {string} name\r\n * @returns {string}\r\n */\r\nconst toHyphen = name => name.replace(/([A-Z])/g, '-$1').toLowerCase();\r\n\r\n/**\r\n * @param {object|array<object>} keyframes\r\n * @param {number|object} [options]\r\n * @param {function|null} [startCallback]\r\n * @param {function|null} [endCallback]\r\n * @return {gSVGObject}\r\n * Notice: the original animateTo method is overwriting for this plugin\r\n */\r\nfunction animateTo (keyframes, options = {duration : 200}, startCallback = null, endCallback = null) {\r\n\r\n  const gSVG = this.gSVG;\r\n\r\n  /**\r\n   * Fixed and configure default values for .animateTo() options\r\n   * @param {object} opts\r\n   * @returns {object}\r\n   */\r\n  const normalizeOptions = (opts) => {\r\n    const normalizedConfig = isObject(opts) ? {...opts} : {duration : opts};\r\n    if (reduceMotion) {\r\n      normalizedConfig.duration = 0;\r\n    }\r\n    normalizedConfig.fill = FILL;\r\n    return normalizedConfig;\r\n  }\r\n\r\n  /**\r\n   * Transform and configure default values for .animate() keyframes. Detect unsupported attributes.\r\n   * @param {object|[{}]} originalKeyframes\r\n   * @returns {[{}]}\r\n   */\r\n  const normalizeKeyframes = (originalKeyframes) => {\r\n    originalKeyframes     = isArray(originalKeyframes) ?\r\n      originalKeyframes :\r\n      [originalKeyframes];\r\n    const computedStyle   = window.getComputedStyle(this._el);\r\n    const normalizeFrames = [];\r\n    const alternativeKeys = new Set();\r\n    for (let keyframe of originalKeyframes) {\r\n      const normalized = {};\r\n      for (let rawKey in keyframe) {\r\n        const key = toCamel(rawKey);\r\n        normalized[key] = keyframe[rawKey];\r\n        if (TO_PIXELS.includes(key)) {\r\n          normalized[key] = normalized[key] + 'px';\r\n        }\r\n        if (!(key in computedStyle)) {\r\n          alternativeKeys.add(key);\r\n        } else if (key === D) {\r\n          normalized.d = `${ PATH }(\"${ normalized.d }\")`\r\n        } else if (key === TRANSFORM) {\r\n          normalized.transform = transform(normalized.transform)\r\n        }\r\n      }\r\n      normalizeFrames.push(normalized);\r\n    }\r\n    addAlternatives(alternativeKeys, normalizeFrames);\r\n    return normalizeFrames;\r\n  }\r\n\r\n  const alternatives    = []\r\n  /**\r\n   * create SMIL animate as alternative\r\n   * @param {Set} keys\r\n   * @param {[{}]} normalizeFrames\r\n   */\r\n  const addAlternatives = (keys, normalizeFrames) => {\r\n    if (keys.size) {\r\n      const computedFrames = new KeyframeEffect(null, normalizeFrames).getKeyframes();\r\n      const initialTime    = this.closest(SVG) ? this.closest(SVG).getCurrentTime() * 1000 : 0;\r\n      for (let key of keys) {\r\n        const altAnimate = gSVG(ANIMATE)\r\n          .attributeName(key)\r\n          .dur(config.duration + MS)\r\n          .begin((0 | initialTime + (options.delay || 0)) + MS)\r\n          .fill(FREEZE);\r\n        if (normalizeFrames.length === 1) {\r\n          altAnimate.to(normalizeFrames[0][key]);\r\n        } else {\r\n          const keyTimes = [];\r\n          const values   = [];\r\n          for (let n in computedFrames) {\r\n            const frame = computedFrames[n];\r\n            if (key in normalizeFrames[n]) {\r\n              keyTimes.push(frame.computedOffset);\r\n              values.push(normalizeFrames[n][key]);\r\n            }\r\n          }\r\n          if (keyTimes[0] !== 0) {\r\n            keyTimes.unshift(0);\r\n            values.unshift(this[key]() || INHERIT);\r\n          }\r\n          if (keyTimes[keyTimes.length - 1] !== 1) {\r\n            keyTimes.push(1);\r\n            values.push(this[key]() || INHERIT);\r\n          }\r\n          altAnimate.keyTimes(keyTimes.join(';')).values(values.join(';'));\r\n        }\r\n        alternatives.push(altAnimate);\r\n        altAnimate.attachTo(this)\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Normalize a transform property\r\n   * @param {object|string} property\r\n   * @returns {string|*}\r\n   */\r\n  const transform = (property) => {\r\n    if (isString(property)) {\r\n      property = JSON.parse('{' +\r\n                            property\r\n                              .replace(/\\s*\\(\\s*/g, ':[')\r\n                              .replace(/\\s*\\)\\s*/g, '],')\r\n                              .split(/\\s*,\\s*|\\s.*/).join(',')\r\n                              .replace(/(\\w+):/g, '\"$1\":')\r\n                              .replace(/,$/, '')\r\n                            + '}');\r\n    }\r\n    let result = '';\r\n    for (let key in property) {\r\n      if (key === ROTATE) {\r\n        const values = transformValue(property[key]);\r\n        if (values.length > 1) {\r\n          result += `${ TRANSLATE }(${ values[1] }${ PX },${ values[2] }${ PX }) `\r\n        }\r\n        result += `${ key }(${ values[0] }${ transformUnit(key) }) `\r\n        if (values.length > 1) {\r\n          result += `${ TRANSLATE }(-${ values[1] }${ PX },-${ values[2] }${ PX }) `\r\n        }\r\n      } else {\r\n        result += `${ key }(${ transformValue(property[key]).map(v => v + transformUnit(key)).join(',') }) `\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Create a normalized transform value array\r\n   * @param {*} value\r\n   * @returns {[]}\r\n   */\r\n  const transformValue = (value) => (isArray(value) ? value : String(value).split(/\\s+|,/));\r\n\r\n  /**\r\n   * Return the transform value\r\n   * @param {string} type\r\n   * @returns {string}\r\n   */\r\n  const transformUnit = (type) => DEG_TYPES.includes(type) ?\r\n    DEG :\r\n    type === TRANSLATE ? PX : '';\r\n\r\n  /**\r\n   * Convert to valida attribute value\r\n   * @param {string|*} value\r\n   * @returns {string|*}\r\n   */\r\n  const value2attribute = (value) =>\r\n    isString(value) ?\r\n      value.replace(/(deg)|(px)/g, '').trim() :\r\n      value\r\n\r\n  /**\r\n   * Transform d CSS property to valid d attribute format\r\n   * @param {string} d\r\n   * @returns {string}\r\n   */\r\n  const d2attribute = (d) => d\r\n    .replace(/(path\\s*\\(\\s*[\"'])|([\"']\\s*\\)\\s*$)/g, '')\r\n    .trim()\r\n    .replace(/([a-zA-Z])\\s*/g, '$1')\r\n    .replace(/\\s+/g, ',');\r\n\r\n  /**\r\n   * Transform d CSS property to valid d attribute format\r\n   * @param {string} transform\r\n   * @returns {string}\r\n   */\r\n  const transform2attribute = (transform) => {\r\n    const regex = /translate\\((.*)px,(.*)px\\) rotate\\((.*)deg\\) translate\\((.*)px,(.*)px\\)\\s+/;\r\n    const match = regex.exec(transform);\r\n    if (match && Number(match[1]) === Number(match[4]) * -1 && Number(match[2]) === Number(match[5]) * -1) {\r\n      transform = transform.replace(regex, `rotate(${match[3]}, ${match[1]}, ${match[2]})`)\r\n    } else {\r\n      transform = value2attribute(transform);\r\n    }\r\n    return transform;\r\n  }\r\n\r\n\r\n  // Main code\r\n  const config    = normalizeOptions(options);\r\n  const frames    = normalizeKeyframes(keyframes);\r\n  const animation = this._el.animate(frames, config);\r\n\r\n  animation.ready.then(() => isFunction(startCallback) && startCallback.call(this, animation));\r\n\r\n  animation.finished.then(() => {\r\n    const lastAttributes = frames[frames.length - 1];\r\n    for (let attr in lastAttributes) {\r\n      const attrKey = toHyphen(attr);\r\n      if (attrKey.startsWith(\"text-\")) {\r\n        this._el.style[attr] = lastAttributes[attr];\r\n      } else if (attr !== OFFSET && attr in lastAttributes) {\r\n        this._el.setAttribute(\r\n          attrKey,\r\n          attrKey === D ?\r\n            d2attribute(lastAttributes[attr]) :\r\n            attrKey === TRANSFORM ?\r\n              transform2attribute(lastAttributes[attr]) :\r\n              value2attribute(lastAttributes[attr]));\r\n      }\r\n    }\r\n    alternatives.forEach(altAnimate => {\r\n      altAnimate[FINISHED](true);\r\n      const animates = this._el.querySelectorAll(ANIMATE);\r\n      const finished = this._el.querySelectorAll(`${ ANIMATE }[${ FINISHED }]`);\r\n      if (animates.length === finished.length) {\r\n        animates.forEach(a => a.remove())\r\n      }\r\n    });\r\n    isFunction(endCallback) && endCallback.call(this, animation);\r\n  });\r\n\r\n  return this;\r\n}\r\n\r\n\r\nexport function svgPlugin (setup) {\r\n  // Update gSVGObject\r\n  setup.extendInstance({\r\n    animateTo\r\n  });\r\n}"],
  "mappings": "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",
  "names": ["FUNCTION", "OBJECT", "STRING", "isObject", "v", "OBJECT", "isString", "STRING", "isFunction", "FUNCTION", "isArray", "v", "toCamel", "name", "x", "y", "SVG", "ANIMATE", "FILL", "FREEZE", "PATH", "D", "TRANSFORM", "ROTATE", "TRANSLATE", "OFFSET", "INHERIT", "FINISHED", "DEG_TYPES", "DEG", "PX", "MS", "TO_PIXELS", "reduceMotion", "mediaQuery", "toHyphen", "name", "animateTo", "keyframes", "options", "startCallback", "endCallback", "gSVG", "normalizeOptions", "opts", "normalizedConfig", "isObject", "normalizeKeyframes", "originalKeyframes", "isArray", "computedStyle", "normalizeFrames", "alternativeKeys", "keyframe", "normalized", "rawKey", "key", "toCamel", "transform", "addAlternatives", "alternatives", "keys", "computedFrames", "initialTime", "altAnimate", "config", "keyTimes", "values", "n", "frame", "property", "isString", "result", "transformValue", "transformUnit", "v", "value", "type", "value2attribute", "d2attribute", "d", "transform2attribute", "regex", "match", "frames", "animation", "isFunction", "lastAttributes", "attr", "attrKey", "animates", "finished", "a", "svgPlugin", "setup"]
}
