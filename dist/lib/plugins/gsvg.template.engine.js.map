{
  "version": 3,
  "sources": ["../../../src/helpers/types.js", "../../../src/helpers/function.create.js", "../../../src/helpers/objects.js", "../../../src/helpers/array.operations.js", "../../../src/lib/plugins/gsvg.animateto.js", "../../../src/lib/plugins/gsvg.template.engine.js", "../../../src/lib/plugins/gsvg.template.engine.script.js"],
  "sourcesContent": ["export const FUNCTION  = 'function';\r\nexport const UNDEFINED = 'undefined';\r\nexport const OBJECT    = 'object';\r\nexport const STRING    = 'string';\r\nexport const ARRAY     = 'array';\r\nexport const NUMBER    = 'number';\r\nexport const BOOLEAN   = 'boolean';\r\nexport const DATE      = 'date';\r\nexport const SYMBOL    = 'symbol';\r\n\r\nexport const EMPTY_STRING = '';\r\nexport const COMA         = ',';\r\nexport const COLON        = ':';\r\nexport const SEMICOLON    = ';';\r\n\r\nexport const isObject    = (v) => typeof v === OBJECT;\r\nexport const isString    = (v) => typeof v === STRING;\r\nexport const isFunction  = (v) => typeof v === FUNCTION;\r\nexport const isNumber    = (v) => typeof v === NUMBER && !isNaN(v);\r\nexport const isUndefined = (v) => typeof v === UNDEFINED;\r\nexport const isSymbol    = (v) => typeof v === SYMBOL;\r\nexport const isBoolean   = (v) => typeof v === BOOLEAN;\r\nexport const isArray     = (v) => Array.isArray(v);\r\nexport const isDate      = (v) => v instanceof Date && !isNaN(v);\r\nexport const isNull      = (v) => v === null;\r\n\r\n/**\r\n * Convert attribute name to camel property name\r\n * @param {string} name\r\n * @return {string}\r\n */\r\nexport const toCamel = name => name.replace(/-([a-z0-9])/g, (x, y) => y.toUpperCase());\r\n\r\n/**\r\n * Converto property name to hyphen attribute name\r\n * @param {string} name\r\n * @return {string}\r\n */\r\nexport const toHyphen = name => {\r\n  name = name.replace(/([A-Z])/g, '-$1').toLowerCase();\r\n  return name[0] === '-' ? name.slice(1) : name;\r\n};\r\n\r\n\r\n/**\r\n * Convert an object property to an attribute string\r\n * @param {Object} value\r\n * @return {string|undefined}\r\n */\r\nexport function object2attribute (value) {\r\n  if (isObject(value)) {\r\n    let str = '';\r\n    for (let key of Object.keys(value)) {\r\n      str += `${ str ? '; ' : '' }${ key }: ${ value[key] }`;\r\n    }\r\n    return str;\r\n  } else if (isString(value)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Convert an attribute string to an object property\r\n * @param {string} value\r\n * @return {Object|undefined}\r\n */\r\nexport function attribute2object (value) {\r\n  if (isString(value)) {\r\n    try {\r\n      const normalized = value\r\n        .replace(/^\\s*{/,'')\r\n        .replace(/}\\s*$/,'')\r\n        .split(/((?:[^;^,\"']|\"[^\"]*\"|'[^']*')+)/)\r\n        .filter(partial => !['', ';', ','].includes(partial.trim()))\r\n        .map(partial => partial.split(':'))\r\n        .map(partial => `\"${ partial[0].trim() }\":${ str2value(\r\n          partial[1].trim(),\r\n          undefined,\r\n          true\r\n        ) }`)\r\n        .join(',');\r\n      return JSON.parse(`{${ normalized }}`);\r\n    } catch (err) {\r\n      console.error(err);\r\n      return undefined;\r\n    }\r\n  } else if (isObject(value)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Convert an attribute string to an array\r\n * @param {string} value\r\n * @return {Object|undefined}\r\n */\r\nexport function attribute2array (value) {\r\n  if (isString(value)) {\r\n    if (value.trim()[0] === '[') {\r\n      return (value.match(/\\[(.*?)[^\\]]]/g) || []).map(arr => attribute2array(arr.substring(\r\n        1,\r\n        arr.length - 1\r\n      )));\r\n    } else {\r\n      return value.split(/[,;]/).map(str => str2value(str.trim()));\r\n    }\r\n  } else if (isArray(value)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Convert an attribute string to an array of objects\r\n * @param {string} value\r\n * @return {Object|undefined}\r\n */\r\nexport function attribute2arrayObject (value) {\r\n  if (isString(value)) {\r\n    if (value.trim()[0] === '[') {\r\n      return (value.match(/\\[(.*?)[^\\]]]/g) || []).map(arr => attribute2object(arr.substring(\r\n        1,\r\n        arr.length - 1\r\n      )));\r\n    } else {\r\n      return [attribute2object(value)];\r\n    }\r\n  } else if (isArray(Array)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n\r\n/**\r\n *\r\n * @param {Object} value\r\n * @return {string|undefined}\r\n */\r\nexport function array2attribute (value) {\r\n  if (isArray(value)) {\r\n    let str = JSON.stringify(value);\r\n    return str.substr(1, str.length - 2)\r\n              .replace(/,/g, ', ')\r\n              .replace(/\"/g, '');\r\n  } else if (isString(value)) {\r\n    return value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Convert a string into a value number, boolean or string (with \"\" if quote is true)\r\n * @private\r\n * @param {string} str\r\n * @param {string} [type]\r\n * @param {boolean} [quote=false]\r\n * @return {any}\r\n */\r\nexport function str2value (str, type, quote = false) {\r\n  if (!isString(str)) {\r\n    return str;\r\n  }\r\n  str = removeDoubleQuote(str.trim());\r\n  if (type === ARRAY) {\r\n    return attribute2array(str);\r\n  }\r\n  if (type === OBJECT) {\r\n    return attribute2object(str);\r\n  }\r\n  if (isUndefined(type) || type === NUMBER) {\r\n    if (isUndefined(str) || str === '') {\r\n      return undefined;\r\n    }\r\n    let value = +str;\r\n    if (!Number.isNaN(value) || type === NUMBER) {\r\n      return value;\r\n    }\r\n  }\r\n  if (isUndefined(type) || type === BOOLEAN) {\r\n    if (str === 'true') {\r\n      return true;\r\n    } else if (str === 'false') {\r\n      return false;\r\n    }\r\n    if (type === BOOLEAN) {\r\n      if (str === '0') {\r\n        return false;\r\n      }\r\n      return !!str;\r\n    }\r\n  }\r\n  if (type === DATE) {\r\n    try {\r\n      let value = new Date(str);\r\n      if (!Number.isNaN(value.getTime())) {\r\n        return value;\r\n      }\r\n    } catch (e) {\r\n      void (0);\r\n    }\r\n    return undefined;\r\n  }\r\n  if (isUndefined(type) || type === STRING) {\r\n    return quote ? `\"${ str }\"` : str;\r\n  }\r\n}\r\n\r\nfunction removeDoubleQuote (str) {\r\n  if (\r\n    (str[0] === '\\'' && str[str.length - 1] === '\\'') ||\r\n    (str[0] === '\"' && str[str.length - 1] === '\"')\r\n  ) {\r\n    return str.substring(1, str.length - 1);\r\n  }\r\n  return str;\r\n}\r\n\r\n/**\r\n *\r\n * @param {string} str\r\n * @returns {boolean}\r\n */\r\nexport function isLikeObject(str) {\r\n  return /^\\s*{(.|\\n)*}\\s*$/.test(str);\r\n}\r\n\r\n/**\r\n *\r\n * @param {string} str\r\n * @returns {boolean}\r\n */\r\nexport function isLikeArray(str) {\r\n  return /^\\s*\\[(.|\\n)*\\]\\s*$/.test(str);\r\n}\r\n\r\n\r\nexport function csvStr2obj (str) {\r\n  let keys = [];\r\n  return str\r\n    .split(/(\\r\\n|\\r|\\n)/)\r\n    .map(r => r.trim())\r\n    .filter(r => r)\r\n    .reduce(\r\n      (result, row, idx) => {\r\n        const obj   = {};\r\n        const parts = row\r\n          .split(/((?:[^;^,\"']|\"[^\"]*\"|'[^']*')+)/)\r\n          .filter(partial => ![EMPTY_STRING, SEMICOLON, COMA].includes(partial.trim()));\r\n        if (idx === 0) {\r\n          keys = [...parts.map(p => JSON.parse(p))];\r\n          return result;\r\n        }\r\n        parts.forEach((part, i) => {\r\n          obj[keys[i]] = JSON.parse(part);\r\n        });\r\n        result.push(obj);\r\n        return result;\r\n      },\r\n      []\r\n    );\r\n}\r\n\r\nexport function jsStr2obj (str) {\r\n  const code = `return (${ str });`\r\n  const ret  = (new Function(code))();\r\n  return typeof ret === 'function' ? ret() : ret;\r\n}\r\n\r\nexport function funcStr2obj (str, $) {\r\n  return (new Function('$', `${ str };let ___$$$ret = {};${\r\n    [...str.matchAll(/\\s*function\\s*(\\w*)/gm)].map(x =>\r\n      `if (typeof ${ x[1] } === 'function') ___$$$ret.${ x[1] } = ${ x[1] };`).join('')\r\n  } return ___$$$ret;`))($);\r\n}", "const cache          = new Map();\r\nconst functionRegExp = /^\\s*function\\s*(\\w*)/gm;\r\n\r\nexport function createFunction (args, code) {\r\n  const key = `${ args.join(',') } ${ code }`;\r\n  if (cache.has(key)) {\r\n    return cache.get(key);\r\n  }\r\n  const fn = new Function(...args, code);\r\n  cache.set(key, fn);\r\n  return fn;\r\n}\r\n\r\nexport function getFunctions (globals, code) {\r\n  const names = [...code.matchAll(functionRegExp)].map(x => x[1]);\r\n  const fn    = createFunction(Object.keys(globals), `${ code }\r\n  \r\n    return {${ names.map(n => `${ n }: typeof ${ n } === 'function' ? ${ n } : undefined`) }};\r\n  `);\r\n  return fn(...Object.values(globals));\r\n}", "import {\r\n  OBJECT, NUMBER, UNDEFINED,\r\n  isObject, isFunction, isString, isUndefined, isNull\r\n} from './types.js';\r\n\r\nconst NOT_EQUAL = false;                            // Return values\r\nconst EQUAL     = true;\r\n\r\n/**\r\n * Create a new object (empty) with same constructor\r\n * @param {object} obj - object as seed\r\n * @returns {object}   - new object\r\n */\r\nexport function createOther (obj) {\r\n  if (obj === null) return null;\r\n  if (obj.constructor) {\r\n    return new obj.constructor();\r\n  }\r\n  return {};\r\n}\r\n\r\n/**\r\n * Clone an object (plain object and array)\r\n * @param {object} obj - object to clone\r\n * @returns {object}   - new object\r\n */\r\nexport function clone (obj) {\r\n  if (!isObject(obj)) {\r\n    return obj;\r\n  }\r\n  const copy = obj === null ? null : Object.assign(createOther(obj), obj);\r\n  for (let p in copy) {\r\n    if (isObject(copy[p])) {\r\n      copy [p] = clone(copy[p]);\r\n    }\r\n  }\r\n  return copy;\r\n}\r\n\r\n/**\r\n * Object comparison (equivalent with same all enumerable properties and equal constructor)\r\n * @param {*} objectA - first object to comparison\r\n * @param {*} objectB - second object to comparison\r\n * @returns {boolean}\r\n */\r\nexport function equal (objectA, objectB) {\r\n  const aStack = [],                             // Stack array\r\n        bStack = [];\r\n\r\n  /**\r\n   * Compare objects\r\n   * @param {object} a - first object\r\n   * @param {object} b - second object\r\n   * @returns {boolean}\r\n   */\r\n  function checkObject (a, b) {\r\n    if (a === null || b === null) {              // if one is null, they are different\r\n      return NOT_EQUAL;\r\n    }\r\n\r\n    if (\r\n      isFunction(a.valueOf) &&         // valueOf() is a function in both values\r\n      isFunction(b.valueOf) &&\r\n      (a !== a.valueOf() || b !== b.valueOf())\r\n    ) {\r\n      return (\r\n        a.valueOf() === b.valueOf() &&\r\n        a.constructor === b.constructor);        // Check if equal\r\n    }\r\n\r\n    if (aStack.indexOf(a) > -1 &&               // Check if the object has been previously processed\r\n        bStack.indexOf(b) > -1) {\r\n      return EQUAL;\r\n    }\r\n    let aKeys = Object.keys(a);                 // Get property keys\r\n    let bKeys = Object.keys(b);\r\n    if (aKeys.length !== bKeys.length) {         // Check the number of properties\r\n      return NOT_EQUAL;\r\n    }\r\n    if (aKeys.length > 0) {\r\n      aStack.push(a);                           // Storage objects into stacks for recursive references\r\n      bStack.push(b);\r\n      let i = aKeys.length;\r\n      while (i--) {                              // Check each property value (recursive call)\r\n        const key = aKeys[i];\r\n        if (!check(a[key], b[key])) {\r\n          return NOT_EQUAL;\r\n        }\r\n      }\r\n    }\r\n    return EQUAL;\r\n  }\r\n\r\n  /**\r\n   * Compare elements\r\n   * @param {*} a - first element\r\n   * @param {*} b - second element\r\n   * @returns {boolean}\r\n   */\r\n  function check (a, b) {\r\n    if (a === b) {                               // Strict comparison\r\n      return EQUAL;\r\n    }\r\n    const aType = typeof a,                      // Get value types\r\n          bType = typeof b;\r\n    if (aType !== bType) {                       // Different type is a not equal value from this point\r\n      return NOT_EQUAL;\r\n    }\r\n    if (aType === NUMBER &&                    // Special case: Not is a Number (NaN !== NaN)\r\n        isNaN(a) &&\r\n        isNaN(b)) {\r\n      return EQUAL;\r\n    }\r\n\r\n    if (aType === OBJECT) {                    // Objects\r\n      return checkObject(a, b);\r\n    }\r\n    return NOT_EQUAL;                            // Not equal\r\n  }\r\n\r\n  return check(objectA, objectB);\r\n}\r\n\r\n/**\r\n * get a deep property\r\n * @param {object} obj\r\n * @param {string|array|Symbol} path\r\n * @returns {undefined|*}\r\n */\r\nexport function getProperty (obj, path) {\r\n  let tmp      = obj;\r\n  let elements = isString(path) ? path.split('.') : path;\r\n  for (let i = 0; i < elements.length; i++) {\r\n    if (isUndefined(tmp[elements[i]])) {\r\n      return undefined;\r\n    }\r\n    tmp = tmp[elements[i]];\r\n  }\r\n  return tmp;\r\n}\r\n\r\n/**\r\n * Create a Schema object\r\n * @param {object} schema\r\n * @returns {{normalize(object): void}}\r\n * @constructor\r\n */\r\nexport function Schema (schema) {\r\n  walker(schema, (obj, key) => {\r\n    if (!obj.$schema && (key === 'properties' || key === 'items')) {\r\n      obj.$schema = {};\r\n      obj.$schema = Schema(obj)\r\n    }\r\n  });\r\n  return {\r\n    normalize : (\r\n      schema.items ?\r\n        (obj) => { // Array\r\n          if (!Array.isArray(obj)) {\r\n            obj = [];\r\n          }\r\n          for (let key in obj) {\r\n            // Update type\r\n            const type = getType(obj[key]);\r\n            if (type !== schema.items.type.name) {\r\n              obj[key] = new schema.items.type(obj[key]).valueOf();\r\n            }\r\n            // Sub schema\r\n            if (schema.items.$schema) {\r\n              obj[key] = schema.items.$schema.normalize(obj[key]);\r\n            }\r\n          }\r\n          return obj;\r\n        } :\r\n        (obj) => { // Object\r\n          if (!isObject(obj)) {\r\n            obj = {};\r\n          }\r\n          const {properties} = schema;\r\n          for (let key in obj) {\r\n            const property = properties[key];\r\n            // Remove unknown values\r\n            if (!property) {\r\n              delete obj[key];\r\n              continue;\r\n            }\r\n            // Update type\r\n            if (getType(obj[key]) !== property.type.name) {\r\n              obj[key] = new property.type(obj[key]).valueOf();\r\n              if (getType(obj[key]) !== property.type.name || (property.type === Number && Number.isNaN(obj[key]))) {\r\n                delete obj[key];\r\n              }\r\n            }\r\n            // Sub schema\r\n            if (property.$schema) {\r\n              obj[key] = property.$schema.normalize(obj[key]);\r\n            }\r\n          }\r\n          // Add missing values\r\n          for (let key in properties) {\r\n            const property = properties[key];\r\n            if (isUndefined(obj[key]) && !isUndefined(property.default)) {\r\n              obj[key] = new property.type(property.default).valueOf();\r\n            }\r\n            if (property.$schema) {\r\n              obj[key] = property.$schema.normalize(obj[key]);\r\n            }\r\n          }\r\n          return obj;\r\n        }\r\n    )\r\n  }\r\n}\r\n\r\n/**\r\n * @typedef walkerCallback\r\n * @type function\r\n * @param {object} obj\r\n * @param {string} key\r\n * @param {*} value\r\n * @param {object} root\r\n * @param {array<string>} keys\r\n */\r\n\r\n/**\r\n * Walk a object keys\r\n * @param {object} obj\r\n * @param {walkerCallback} callback\r\n */\r\nexport function walker (obj, callback) {\r\n  if (!isObject(obj) || !isFunction(callback)) {\r\n    return;\r\n  }\r\n  (function inspect (currentObj, keys) {\r\n    for (let key in currentObj) {\r\n      keys.push(key);\r\n      if (isObject(currentObj[key])) {\r\n        inspect(currentObj[key], keys);\r\n      }\r\n      callback(currentObj, key, currentObj[key], obj, keys);\r\n      keys.pop();\r\n    }\r\n  })(obj, []);\r\n}\r\n\r\nfunction getType (value) {\r\n  if (isNull(value)) {\r\n    return 'null';\r\n  }\r\n  if (isUndefined(value)) {\r\n    return UNDEFINED;\r\n  }\r\n  return value.constructor.name\r\n}", "import { getProperty }           from \"./objects.js\";\r\nimport { isUndefined, isString } from \"./types.js\";\r\n\r\nconst DIRECT  = Symbol();\r\nconst INITIAL = Symbol();\r\n\r\nfunction getValue (obj, prop) {\r\n  if (prop === DIRECT) {\r\n    return obj;\r\n  }\r\n  return getProperty(obj, prop);\r\n}\r\n\r\nexport function Operations (data) {\r\n\r\n  const cache = {}\r\n\r\n  /**\r\n   *\r\n   * @param {String} name\r\n   * @param {Number|Object|Symbol} init\r\n   * @param {Function} op\r\n   * @param {Function} [finish]\r\n   * @returns {Function}\r\n   */\r\n  function operation (name, init, op, finish) {\r\n    if (!cache[name]) {\r\n      cache[name] = {};\r\n    }\r\n    return (arr = undefined, prop = DIRECT) => {\r\n      if (isString(arr) || isUndefined(arr)) {\r\n        prop = arr || DIRECT;\r\n        if ((prop in cache[name])) {\r\n          return cache[name][prop];\r\n        }\r\n      } else {\r\n        data = arr;\r\n      }\r\n      let result = data.reduce((result, record) => {\r\n        const value = getValue(record, prop);\r\n        if (typeof value === 'undefined') {\r\n          return result;\r\n        }\r\n        return result === INITIAL ? value : op(result, value);\r\n      }, init);\r\n      result     = typeof finish === 'function' ? finish(result) : result;\r\n      if (data !== arr) {\r\n        cache[name][prop] = result\r\n      }\r\n      return result;\r\n    }\r\n  }\r\n\r\n\r\n  const min      = operation('min', INITIAL, (result, value) => value > result ? result : value);\r\n  const max      = operation('max', INITIAL, (result, value) => value < result ? result : value);\r\n  const count    = operation('count', 0, (result) => result + 1);\r\n  const sum      = operation('sum', 0, (result, value) => value + result);\r\n  const avg      = operation('avg', {n : 0, i : 0}, (result, value) => {\r\n    result.n++;\r\n    result.i += Number(value);\r\n    return result;\r\n  }, (result) => result.i / result.n);\r\n  const distinct = operation('distinct', new Set(), (result, value) => {\r\n    result.add(value);\r\n    return result;\r\n  }, (result) => [...result]);\r\n\r\n  return {\r\n    min,\r\n    max,\r\n    sum,\r\n    count,\r\n    avg,\r\n    distinct,\r\n  }\r\n}\r\n", "import { isObject, isString, isFunction, isArray } from '../../helpers/types.js';\r\n\r\nconst SVG       = 'SVG';\r\nconst ANIMATE   = 'animate';\r\nconst FILL      = 'none';\r\nconst FREEZE    = 'freeze';\r\nconst PATH      = 'path';\r\nconst D         = 'd';\r\nconst TRANSFORM = 'transform';\r\nconst ROTATE    = 'rotate';\r\nconst TRANSLATE = 'translate';\r\nconst OFFSET    = 'offset';\r\nconst INHERIT   = 'inherit';\r\nconst FINISHED  = 'finished';\r\nconst DEG_TYPES = [ROTATE, 'skewX', 'skewY'];\r\nconst DEG       = 'deg';\r\nconst PX        = 'px';\r\nconst MS        = 'ms';\r\n\r\n/**\r\n * The reduced-motion flag\r\n * @type {boolean}\r\n */\r\nlet reduceMotion = false;\r\nif (window.matchMedia) {\r\n  const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\r\n  reduceMotion     = mediaQuery.matches;\r\n  mediaQuery.addEventListener('change', () => {\r\n    reduceMotion = mediaQuery.matches;\r\n  });\r\n}\r\n\r\n/**\r\n * Convert property name to attribute with hyphens\r\n * @param {string} name\r\n * @returns {string}\r\n */\r\nconst toHyphen = name => name.replace(/([A-Z])/g, '-$1').toLowerCase();\r\n\r\n/**\r\n * @param {object|array<object>} keyframes\r\n * @param {number|object} [options]\r\n * @param {function|null} [startCallback]\r\n * @param {function|null} [endCallback]\r\n * @return {gSVGObject}\r\n * Notice: the original animateTo method is overwriting for this plugin\r\n */\r\nfunction animateTo (keyframes, options = {duration : 200}, startCallback = null, endCallback = null) {\r\n\r\n  const gSVG = this.gSVG;\r\n\r\n  /**\r\n   * Fixed and configure default values for .animateTo() options\r\n   * @param {object} opts\r\n   * @returns {object}\r\n   */\r\n  const normalizeOptions = (opts) => {\r\n    const normalizedConfig = isObject(opts) ? Object.assign({}, opts) : {duration : opts};\r\n    if (reduceMotion) {\r\n      normalizedConfig.duration = 0;\r\n    }\r\n    normalizedConfig.fill = FILL;\r\n    return normalizedConfig;\r\n  }\r\n\r\n  /**\r\n   * Transform and configure default values for .animate() keyframes. Detect unsupported attributes.\r\n   * @param {object|[{}]} originalKeyframes\r\n   * @returns {[{}]}\r\n   */\r\n  const normalizeKeyframes = (originalKeyframes) => {\r\n    originalKeyframes     = isArray(originalKeyframes) ?\r\n      originalKeyframes :\r\n      [originalKeyframes];\r\n    const computedStyle   = window.getComputedStyle(this._el);\r\n    const normalizeFrames = [];\r\n    const alternativeKeys = new Set();\r\n    for (let keyframe of originalKeyframes) {\r\n      const normalized = Object.assign({}, keyframe);\r\n      for (let key in normalized) {\r\n        if (!(key in computedStyle)) {\r\n          alternativeKeys.add(key);\r\n        } else if (key === D) {\r\n          normalized.d = `${ PATH }(\"${ normalized.d }\")`\r\n        } else if (key === TRANSFORM) {\r\n          normalized.transform = transform(normalized.transform)\r\n        }\r\n      }\r\n      normalizeFrames.push(normalized);\r\n    }\r\n    addAlternatives(alternativeKeys, normalizeFrames);\r\n    return normalizeFrames;\r\n  }\r\n\r\n  const alternatives    = []\r\n  /**\r\n   * create SMIL animate as alternative\r\n   * @param {Set} keys\r\n   * @param {[{}]} normalizeFrames\r\n   */\r\n  const addAlternatives = (keys, normalizeFrames) => {\r\n    if (keys.size) {\r\n      const computedFrames = new KeyframeEffect(null, normalizeFrames).getKeyframes();\r\n      const initialTime    = this.closest(SVG) ? this.closest(SVG).getCurrentTime() * 1000 : 0;\r\n      for (let key of keys) {\r\n        const altAnimate = gSVG(ANIMATE)\r\n          .attributeName(key)\r\n          .dur(config.duration + MS)\r\n          .begin((0 | initialTime + (options.delay || 0)) + MS)\r\n          .fill(FREEZE);\r\n        if (normalizeFrames.length === 1) {\r\n          altAnimate.to(normalizeFrames[0][key]);\r\n        } else {\r\n          const keyTimes = [];\r\n          const values   = [];\r\n          for (let n in computedFrames) {\r\n            const frame = computedFrames[n];\r\n            if (key in normalizeFrames[n]) {\r\n              keyTimes.push(frame.computedOffset);\r\n              values.push(normalizeFrames[n][key]);\r\n            }\r\n          }\r\n          if (keyTimes[0] !== 0) {\r\n            keyTimes.unshift(0);\r\n            values.unshift(this[key]() || INHERIT);\r\n          }\r\n          if (keyTimes[keyTimes.length - 1] !== 1) {\r\n            keyTimes.push(1);\r\n            values.push(this[key]() || INHERIT);\r\n          }\r\n          altAnimate.keyTimes(keyTimes.join(';')).values(values.join(';'));\r\n        }\r\n        alternatives.push(altAnimate);\r\n        altAnimate.attachTo(this)\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Normalize a transform property\r\n   * @param {object|string} property\r\n   * @returns {string|*}\r\n   */\r\n  const transform = (property) => {\r\n    if (isString(property)) {\r\n      property = JSON.parse('{' +\r\n                            property\r\n                              .replace(/\\s*\\(\\s*/g, ':[')\r\n                              .replace(/\\s*\\)\\s*/g, '],')\r\n                              .split(/\\s*,\\s*|\\s.*/).join(',')\r\n                              .replace(/(\\w+):/g, '\"$1\":')\r\n                              .replace(/,$/, '')\r\n                            + '}');\r\n    }\r\n    let result = '';\r\n    for (let key in property) {\r\n      if (key === ROTATE) {\r\n        const values = transformValue(property[key]);\r\n        if (values.length > 1) {\r\n          result += `${ TRANSLATE }(${ values[1] }${ PX },${ values[2] }${ PX }) `\r\n        }\r\n        result += `${ key }(${ values[0] }${ transformUnit(key) }) `\r\n        if (values.length > 1) {\r\n          result += `${ TRANSLATE }(-${ values[1] }${ PX },-${ values[2] }${ PX }) `\r\n        }\r\n      } else {\r\n        result += `${ key }(${ transformValue(property[key]).map(v => v + transformUnit(key)).join(',') }) `\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Create a normalized transform value array\r\n   * @param {*} value\r\n   * @returns {[]}\r\n   */\r\n  const transformValue = (value) => (isArray(value) ? value : String(value).split(/\\s+|,/));\r\n\r\n  /**\r\n   * Return the transform value\r\n   * @param {string} type\r\n   * @returns {string}\r\n   */\r\n  const transformUnit = (type) => DEG_TYPES.includes(type) ?\r\n    DEG :\r\n    type === TRANSLATE ? PX : '';\r\n\r\n  /**\r\n   * Convert to valida attribute value\r\n   * @param {string|*} value\r\n   * @returns {string|*}\r\n   */\r\n  const value2attribute = (value) =>\r\n    isString(value) ?\r\n      value.replace(/(deg)|(px)/g, '').trim() :\r\n      value\r\n\r\n  /**\r\n   * Transform d CSS property to valid d attribute format\r\n   * @param {string} d\r\n   * @returns {string}\r\n   */\r\n  const d2attribute = (d) => d\r\n    .replace(/(path\\s*\\(\\s*[\"'])|([\"']\\s*\\)\\s*$)/g, '')\r\n    .trim()\r\n    .replace(/([a-zA-Z])\\s*/g, '$1')\r\n    .replace(/\\s+/g, ',');\r\n\r\n  // Main code\r\n  const config    = normalizeOptions(options);\r\n  const frames    = normalizeKeyframes(keyframes);\r\n  const animation = this._el.animate(frames, config);\r\n\r\n  animation.ready.then(() => isFunction(startCallback) && startCallback.call(this, animation));\r\n\r\n  animation.finished.then(() => {\r\n    const lastAttributes = frames[frames.length - 1];\r\n    for (let attr in lastAttributes) {\r\n      const attrKey = toHyphen(attr);\r\n      if (/^text-/.test(attrKey)) {\r\n        this._el.style[attr] = lastAttributes[attr];\r\n      } else if (attr !== OFFSET && attr in lastAttributes) {\r\n        this._el.setAttribute(\r\n          attrKey,\r\n          attrKey === D ?\r\n            d2attribute(lastAttributes[attr]) :\r\n            value2attribute(lastAttributes[attr]));\r\n      }\r\n    }\r\n    alternatives.forEach(altAnimate => {\r\n      altAnimate[FINISHED](true);\r\n      const animates = this._el.querySelectorAll(ANIMATE);\r\n      const finished = this._el.querySelectorAll(`${ ANIMATE }[${ FINISHED }]`);\r\n      if (animates.length === finished.length) {\r\n        animates.forEach(a => a.remove())\r\n      }\r\n    });\r\n    isFunction(endCallback) && endCallback.call(this, animation);\r\n  });\r\n\r\n  return this;\r\n}\r\n\r\n\r\nexport default function animateToPlugin (setup) {\r\n\r\n  // Update gSVGObject\r\n  setup.extendInstance({\r\n    animateTo\r\n  });\r\n\r\n}", "import {\r\n  ARRAY, OBJECT, NUMBER,\r\n  isArray, isObject, isNumber, isFunction, isUndefined\r\n}                         from '../../helpers/types.js';\r\nimport { createFunction } from '../../helpers/function.create.js';\r\nimport { Operations }     from '../../helpers/array.operations.js';\r\nimport { clone }          from '../../helpers/objects.js';\r\nimport animateToPlugin    from './gsvg.animateto.js';\r\n\r\nconst CLONED     = Symbol();\r\nconst CLONES     = Symbol();\r\nconst TEMPLATE   = Symbol();\r\nconst EVENTS     = Symbol();\r\nconst UNKNOWN    = 'unknown';\r\nconst LABEL      = 'Graphane SVG Template Engine:';\r\nconst directives = [];\r\n\r\nconst TRANSFORM_CONVERSION = (keys) =>\r\n  keys.reduce((obj, name) => {\r\n    obj[name] = (...args) => `${ name }(${ args.join(',') }) `;\r\n    return obj\r\n  }, {})\r\nconst TRANSFORM_ATTRIBUTES = ['transform', 'gradientTransform', 'patternTransform'];\r\nconst TRANSFORM_FUNCTIONS  = TRANSFORM_CONVERSION(\r\n  ['matrix', 'matrix3d', 'perspective', 'rotate', 'rotate3d', 'rotateX', 'rotateY', 'rotateZ',\r\n   'scale', 'scale3d', 'scaleX', 'scaleY', 'scaleZ', 'skew', 'skewX', 'skewY', 'translate',\r\n   'translate3d', 'translateX', 'translateY', 'translateZ']\r\n);\r\n\r\n\r\n/**\r\n * g-context\r\n * Directive that sets the content of an element to the result of the given expression, especially\r\n * with <tspan></tspan> and <text></text>.\r\n * @example\r\n * <text g-content:=\"value\"></text>\r\n */\r\ndefineDirective({\r\n  name : 'g-content',\r\n  execute (gObject, {expression, data, evalExpression}) {\r\n    gObject.content(evalExpression(expression, data));\r\n  }\r\n});\r\n\r\n/**\r\n * g-if\r\n * Directive that provides an expressive way to show and hide elements.\r\n * @example\r\n * <g g-if=\"value\"></g>\r\n */\r\ndefineDirective({\r\n  name : 'g-if',\r\n  execute (gObject, {expression, data, evalExpression}) {\r\n    gObject.style.visibility(evalExpression(expression, data) ? 'inherit' : 'hidden');\r\n  }\r\n});\r\n\r\n/**\r\n * g-bind: or :\r\n * Directive allowing to set attributes on elements based on the result of the expression. It is\r\n * necessary to indicate the attribute name after the directive or the shorthand.\r\n * @example\r\n * <rect g-bind:x=\"valueX\" :y=\"valueY\"></rect>\r\n */\r\ndefineDirective({\r\n  name     : 'g-bind',\r\n  alias    : ':',\r\n  argument : true,\r\n  execute (gObject, {expression, argument, data, evalExpression}) {\r\n    const context = {\r\n      ...data,\r\n      ...(TRANSFORM_ATTRIBUTES.includes(argument) ? TRANSFORM_FUNCTIONS : {}),\r\n      $ : {\r\n        ...data.$,\r\n        d : argument === 'd' ? gObject.$d : undefined,\r\n        animate (value, duration = 200, delay = 0) {\r\n          gObject.animateTo({[argument] : value}, {duration, delay});\r\n        }\r\n      },\r\n    }\r\n    const value   = evalExpression(expression, context);\r\n    if (argument === 'class') {\r\n      if (isArray(value)) {\r\n        gObject.classList.add(...value.filter(val => !!val));\r\n        return;\r\n      }\r\n      if (isObject(value)) {\r\n        Object.entries(value).forEach(([key, val]) => {\r\n          val ? gObject.classList.add(key) : gObject.classList.remove(key)\r\n        });\r\n        return;\r\n      }\r\n      if (value) {\r\n        gObject.classList.add(value);\r\n      }\r\n      return;\r\n    }\r\n    if (argument === 'style') {\r\n      Object.entries(value).forEach(([key, val]) => gObject.style[key](val));\r\n      return;\r\n    }\r\n    if (!isUndefined(value)) {\r\n      gObject[argument](argument === 'd' ? '' + value : value);\r\n    }\r\n  }\r\n});\r\n\r\n/**\r\n * g-on: or @\r\n * Directive than allows you to easily run code on dispatched events.\r\n * @example\r\n * <rect g-on:click=\"run\"></rect>\r\n */\r\ndefineDirective({\r\n  name     : 'g-on',\r\n  alias    : '@',\r\n  argument : true,\r\n  execute (gObject, {expression, argument : event, data, evalExpression}) {\r\n    let handler     = evalExpression(expression, data);\r\n    gObject[EVENTS] = gObject[EVENTS] || {};\r\n    const manager   = gObject[EVENTS][event];\r\n    if (isFunction(handler)) {\r\n      if (manager && !manager.has(handler)) {\r\n        gObject.removeEventListener(event, [...manager.values()][0]);\r\n      }\r\n      const wrapper = (evt) => handler.call(gObject, evt);\r\n      gObject.addEventListener(event, wrapper);\r\n      gObject[EVENTS][event] = new Map();\r\n      gObject[EVENTS][event].set(handler, wrapper);\r\n      if (event === 'load') {\r\n        gObject.dispatchEvent(new Event('load'));\r\n      }\r\n    }\r\n  }\r\n});\r\n\r\n/**\r\n * g-for\r\n * Directive allows you to create elements by iterating through a list. It is only aceptable over\r\n * <defs></defs> element and clones the content for each item into the collection.\r\n * @example\r\n * <defs g-for=\"record of records\">\r\n *   <rect :x=\"record.x\" :y=\"record.y\" :width=\"record.width\" :height=\"record.height\"></rect>\r\n * </defs>\r\n */\r\ndefineDirective({\r\n  name     : 'g-for',\r\n  template : true,\r\n  execute (def, {expression, data}) {\r\n    def[CLONES] = def[CLONES] || [];\r\n    let n       = 0;\r\n    evalForExpression(\r\n      expression,\r\n      data,\r\n      (subData) => {\r\n        if (def[CLONES][n]) {\r\n          process(def[CLONES][n], subData, false);\r\n        } else {\r\n          const g = def.gSVG('g');\r\n          def.children().forEach(child => {\r\n            g.add(child.cloneNode(true));\r\n          });\r\n          process(g, subData);\r\n          def.before(g.el);\r\n          g[CLONED] = true;\r\n          def[CLONES].push(g);\r\n        }\r\n        n++;\r\n      },\r\n      (subData) => {\r\n        while (def[CLONES].length > subData.length) {\r\n          def[CLONES].pop().remove();\r\n        }\r\n      });\r\n  }\r\n});\r\n\r\n\r\n/**\r\n * defineDirective - add a new directive\r\n * @param {Object}   config\r\n * @param {Function} execute\r\n */\r\nfunction defineDirective ({name, alias, argument, template, execute}) {\r\n\r\n  let source  = `^(${\r\n    name\r\n  }${\r\n    argument ? ':' : ''\r\n  }${\r\n    alias ? `|${ alias })` : ')'\r\n  }${\r\n    argument ? `(.*)$` : `$`\r\n  }`\r\n  const check = new RegExp(source, 'i')\r\n\r\n  directives.push({\r\n    name,\r\n    alias,\r\n    argument,\r\n    template,\r\n    execute,\r\n    check\r\n  });\r\n\r\n}\r\n\r\n/**\r\n * findDirective - seeks a defined directive\r\n * @param {string} key\r\n * @returns {Object}\r\n */\r\nfunction findDirective (key) {\r\n  for (const definition of directives) {\r\n    const match = definition.check.exec(key);\r\n    if (match) {\r\n      let argument = match[2];\r\n      return {...definition, argument}\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * getVariables - analyzes a string with destructuring and extract the final variables\r\n * @param {string} expression\r\n * @returns {Array<string>}\r\n */\r\nfunction getVariables (expression) {\r\n  return expression\r\n    .replace(/[{}()[\\]]/g, '')\r\n    .split(',')\r\n    .map(k => k.includes(':') ? k.split(':')[1] : k)\r\n    .map(k => k.trim());\r\n}\r\n\r\n/**\r\n * toIterator - convert a variable into an Array\r\n * @param {any} v\r\n * @returns {{iterator: Array, type: string}}\r\n */\r\nfunction toArray (v) {\r\n  if (v[Symbol.iterator]) {\r\n    return {iterator : [...v], type : ARRAY};\r\n  }\r\n  if (isNumber(v)) {\r\n    return {iterator : Array(v < 0 ? 0 : v).fill(0).map((v, i) => i), type : NUMBER};\r\n  }\r\n  if (isObject(v)) {\r\n    return {iterator : Object.entries(v).map(m => m.reverse()), type : OBJECT};\r\n  }\r\n  return {iterator : v, type : UNKNOWN};\r\n}\r\n\r\n/**\r\n * evalExpression - evaluate an expression with a data context\r\n * @param {string} code\r\n * @param {object} data\r\n * @returns {*}\r\n */\r\nfunction evalExpression (code, data) {\r\n  try {\r\n    const fn = createFunction(\r\n      Object.keys(data).filter(n => !isNumber(n)),\r\n      `return ( ${ code } ); `\r\n    );\r\n    return fn(...Object.values(data));\r\n  } catch (err) {\r\n    console.warn(LABEL, err.message);\r\n  }\r\n}\r\n\r\n/**\r\n * evalForExpression - evaluates an expression ` in ` with a data context and calls for each\r\n * occurrence to the callback\r\n * @param {string} code\r\n * @param {object} data\r\n * @param {function} each\r\n * @param {function} final\r\n * @returns {*}\r\n */\r\nfunction evalForExpression (code, data, each, final) {\r\n  const iteratorName = '__$$iterator';\r\n  const callbackName = '__$$callback';\r\n  const finalName    = '__$$final';\r\n  try {\r\n    let [left, right]      = code.split(' of ');\r\n    left                   = left.trim();\r\n    right                  = right.trim();\r\n    const value            = evalExpression(right, data) || [];\r\n    const {iterator, type} = toArray(value);\r\n    if (type === OBJECT && left[0] !== '[') {\r\n      left = `[${ left.replace(/(^\\()|(\\)$)/g, '') }]`;\r\n    }\r\n    const variables    = getVariables(left);\r\n    const args         = left[0] !== '(' ? `(${ left })` : left;\r\n    const dataKeys     = Object.keys(data);\r\n    const codeFunction = `\r\n      ${ iteratorName }.forEach(${ args } => {\r\n        ${ callbackName }({${ dataKeys }${ dataKeys.length ?\r\n      ',' :\r\n      '' }${ variables.join(',') }});\r\n      });\r\n      ${ finalName }(${ iteratorName });\r\n    `;\r\n    const fn           = createFunction([...dataKeys, iteratorName, callbackName, finalName], codeFunction);\r\n    return fn(...Object.values(data), iterator, each, final);\r\n  } catch (err) {\r\n    console.warn(LABEL, err);\r\n  }\r\n}\r\n\r\n/**\r\n * process - evaluates a gObject object and renders the content with the directives, creating new\r\n * elements, adding content, filling in attributes, etc.\r\n * @param {Object} el\r\n * @param {Object} data\r\n * @param {boolean} [checkCloned=true]\r\n * @example\r\n * svg.render(records)\r\n */\r\nfunction process (el, data, checkCloned = true) {\r\n  if (checkCloned && el[CLONED]) {\r\n    return\r\n  }\r\n  el[TEMPLATE] = el[TEMPLATE] || [];\r\n  const attrs  = el.attributes();\r\n  for (let attr of [...attrs]) {\r\n    const attributeName = attr.name;\r\n    const result        = findDirective(attributeName);\r\n    if (result) {\r\n      el[TEMPLATE].push({...result, expression : attr.value});\r\n      el.removeAttribute(attributeName);\r\n    }\r\n  }\r\n  let template = false;\r\n  for (let directive of el[TEMPLATE]) {\r\n    directive.execute(el, {...directive, data, evalExpression});\r\n    template = directive.template || template;\r\n  }\r\n  if (!template) {\r\n    for (const child of el.children()) {\r\n      process(child, data);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @param {Object|Array} [context]\r\n */\r\nfunction render (context = {}) {\r\n  process(this, {\r\n    ...context,\r\n    ...(Array.isArray(context.data) ? {} : context.data),\r\n    $ : context.data ? {\r\n      ...context.$,\r\n      ...Operations(context.data),\r\n      data    : context.data,\r\n      rawData : clone(context.data),\r\n    } : {}\r\n  });\r\n}\r\n\r\n\r\n/**\r\n * Install template plugin\r\n * @param {object} setup\r\n * @example gSVG.install(templateEngine)\r\n */\r\nexport default function templateEngine (setup) {\r\n  // Dependencies\r\n  animateToPlugin(setup);\r\n  // Install\r\n  setup.extendInstance({\r\n    render\r\n  });\r\n  setup.extendSetup({\r\n    extendTemplate : {\r\n      defineDirective,\r\n      obtainDirective (name) {\r\n        return directives.find(directive => directive.name === name);\r\n      }\r\n    }\r\n  })\r\n}", "import plugin from './gsvg.template.engine.js';\r\nif (gSVG) {\r\n  gSVG.install(plugin);\r\n}\r\n"],
  "mappings": "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",
  "names": ["FUNCTION", "UNDEFINED", "OBJECT", "STRING", "ARRAY", "NUMBER", "isObject", "v", "OBJECT", "isString", "STRING", "isFunction", "FUNCTION", "isNumber", "NUMBER", "isUndefined", "UNDEFINED", "isArray", "v", "cache", "createFunction", "args", "code", "key", "cache", "fn", "createOther", "obj", "clone", "isObject", "copy", "p", "getProperty", "obj", "path", "tmp", "elements", "isString", "i", "isUndefined", "DIRECT", "INITIAL", "getValue", "obj", "prop", "getProperty", "Operations", "data", "cache", "operation", "name", "init", "op", "finish", "arr", "isString", "isUndefined", "result", "record", "value", "min", "max", "count", "sum", "avg", "distinct", "SVG", "ANIMATE", "FILL", "FREEZE", "PATH", "D", "TRANSFORM", "ROTATE", "TRANSLATE", "OFFSET", "INHERIT", "FINISHED", "DEG_TYPES", "DEG", "PX", "MS", "reduceMotion", "mediaQuery", "toHyphen", "name", "animateTo", "keyframes", "options", "startCallback", "endCallback", "gSVG", "normalizeOptions", "opts", "normalizedConfig", "isObject", "normalizeKeyframes", "originalKeyframes", "isArray", "computedStyle", "normalizeFrames", "alternativeKeys", "keyframe", "normalized", "key", "transform", "addAlternatives", "alternatives", "keys", "computedFrames", "initialTime", "altAnimate", "config", "keyTimes", "values", "n", "frame", "property", "isString", "result", "transformValue", "transformUnit", "v", "value", "type", "value2attribute", "d2attribute", "d", "frames", "animation", "isFunction", "lastAttributes", "attr", "attrKey", "animates", "finished", "a", "animateToPlugin", "setup", "CLONED", "CLONES", "TEMPLATE", "EVENTS", "UNKNOWN", "LABEL", "directives", "TRANSFORM_CONVERSION", "keys", "obj", "name", "args", "TRANSFORM_ATTRIBUTES", "TRANSFORM_FUNCTIONS", "defineDirective", "gObject", "expression", "data", "evalExpression", "argument", "context", "value", "duration", "delay", "isArray", "val", "isObject", "key", "isUndefined", "event", "handler", "manager", "isFunction", "wrapper", "evt", "def", "n", "evalForExpression", "subData", "process", "g", "child", "alias", "template", "execute", "source", "check", "findDirective", "definition", "match", "getVariables", "k", "toArray", "v", "ARRAY", "isNumber", "i", "NUMBER", "m", "OBJECT", "code", "createFunction", "err", "each", "final", "iteratorName", "callbackName", "finalName", "left", "right", "iterator", "type", "variables", "dataKeys", "codeFunction", "el", "checkCloned", "attrs", "attr", "attributeName", "result", "directive", "render", "Operations", "clone", "templateEngine", "setup", "animateToPlugin", "templateEngine"]
}
